<!DOCTYPE HTML>
<html lang="en-US" >
    
    <head>
        
        <meta charset="UTF-8">
        <title>协议 | The Swift Programming Language 中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 0.7.1">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        <script src="../gitbook/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        
    
    
    <meta name="author" content="muxuezi">
    
    
    <link rel="next" href="../chapter2/22_Generics.html" />
    
    
    <link rel="prev" href="../chapter2/20_Extensions.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="../gitbook/style.css">


        
    <div class="book" data-github="muxuezi/swift-codeblocks" data-level="2.21" data-basepath=".." data-revision="1408502179633">
    <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    
    <a href="https://github.com/muxuezi/swift-codeblocks" target="_blank" class="btn pull-left home-bookmark" aria-label="GitHub home"><i class="fa fa-bookmark-o"></i></a>
    
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    <span id="font-settings-wrapper">
        <a href="#" class="btn pull-left toggle-font-settings" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="btn-group btn-block">
        <button id="reduce-font-size" class="btn btn-default">A</button>
        <button id="enlarge-font-size" class="btn btn-default">A</button>
    </div>

    <ul class="list-group font-family-list">
        <li class="list-group-item" data-font="0">Serif</li>
        <li class="list-group-item" data-font="1">Sans</li>
    </ul>

    <div class="btn-group btn-group-xs btn-block color-theme-list">
        <button type="button" class="btn btn-default" id="color-theme-preview-0" data-theme="0">White</button>
        <button type="button" class="btn btn-default" id="color-theme-preview-1" data-theme="1">Sepia</button>
        <button type="button" class="btn btn-default" id="color-theme-preview-2" data-theme="2">Night</button>
    </div>
</div>

    </span>

    <!-- Actions Right -->
    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-spinner fa-spin"></i>
        <a href="../" >The Swift Programming Language 中文版</a>
    </h1>
</div>

    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Search" class="form-control" />
    </div>
    <ul class="summary">
        
        
        
        <li>
            <a href="https://github.com/muxuezi" target="blank" class="author-link">About the author</a>
        </li>
        

        
        
        <li>
            <a href="https://github.com/muxuezi/swift-codeblocks/issues" target="blank" class="issues-link">Questions and Issues</a>
        </li>
        

        
        
        <li>
            <a href="https://github.com/muxuezi/swift-codeblocks/edit/master/chapter2/21_Protocols.md" target="blank" class="contribute-link">Edit and Contribute</a>
        </li>
        

	

        
        <li class="divider"></li>
        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../index.html">
                        <i class="fa fa-check"></i>
                        
                         Introduction
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="chapter1/chapter1.html">
            
                
                    <a href="../chapter1/chapter1.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         欢迎使用 Swift
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="1.1" data-path="chapter1/01_Swift.html">
            
                
                    <a href="../chapter1/01_Swift.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.1.</b>
                        
                         关于 Swift
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.2" data-path="chapter1/02_A_Swift_Tour.html">
            
                
                    <a href="../chapter1/02_A_Swift_Tour.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.2.</b>
                        
                         Swift 初见
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.3" data-path="chapter1/03_Revision_History.html">
            
                
                    <a href="../chapter1/03_Revision_History.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.3.</b>
                        
                         Swift 版本历史记录
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    
        
        <li class="chapter " data-level="2" data-path="chapter2/chapter2.html">
            
                
                    <a href="../chapter2/chapter2.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                         Swift 教程
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="2.1" data-path="chapter2/01_The_Basics.html">
            
                
                    <a href="../chapter2/01_The_Basics.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.1.</b>
                        
                         基础部分
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.2" data-path="chapter2/02_Basic_Operators.html">
            
                
                    <a href="../chapter2/02_Basic_Operators.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.2.</b>
                        
                         基本运算符
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.3" data-path="chapter2/03_Strings_and_Characters.html">
            
                
                    <a href="../chapter2/03_Strings_and_Characters.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.3.</b>
                        
                         字符串和字符
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.4" data-path="chapter2/04_Collection_Types.html">
            
                
                    <a href="../chapter2/04_Collection_Types.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.4.</b>
                        
                         集合类型
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.5" data-path="chapter2/05_Control_Flow.html">
            
                
                    <a href="../chapter2/05_Control_Flow.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.5.</b>
                        
                         控制流
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.6" data-path="chapter2/06_Functions.html">
            
                
                    <a href="../chapter2/06_Functions.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.6.</b>
                        
                         函数
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.7" data-path="chapter2/07_Closures.html">
            
                
                    <a href="../chapter2/07_Closures.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.7.</b>
                        
                         闭包
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.8" data-path="chapter2/08_Enumerations.html">
            
                
                    <a href="../chapter2/08_Enumerations.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.8.</b>
                        
                         枚举
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.9" data-path="chapter2/09_Classes_and_Structures.html">
            
                
                    <a href="../chapter2/09_Classes_and_Structures.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.9.</b>
                        
                         类和结构体
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.10" data-path="chapter2/10_Properties.html">
            
                
                    <a href="../chapter2/10_Properties.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.10.</b>
                        
                         属性
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.11" data-path="chapter2/11_Methods.html">
            
                
                    <a href="../chapter2/11_Methods.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.11.</b>
                        
                         方法
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.12" data-path="chapter2/12_Subscripts.html">
            
                
                    <a href="../chapter2/12_Subscripts.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.12.</b>
                        
                         下标脚本
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.13" data-path="chapter2/13_Inheritance.html">
            
                
                    <a href="../chapter2/13_Inheritance.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.13.</b>
                        
                         继承
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.14" data-path="chapter2/14_Initialization.html">
            
                
                    <a href="../chapter2/14_Initialization.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.14.</b>
                        
                         构造过程
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.15" data-path="chapter2/15_Deinitialization.html">
            
                
                    <a href="../chapter2/15_Deinitialization.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.15.</b>
                        
                         析构过程
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.16" data-path="chapter2/16_Automatic_Reference_Counting.html">
            
                
                    <a href="../chapter2/16_Automatic_Reference_Counting.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.16.</b>
                        
                         自动引用计数
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.17" data-path="chapter2/17_Optional_Chaining.html">
            
                
                    <a href="../chapter2/17_Optional_Chaining.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.17.</b>
                        
                         可选链
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.18" data-path="chapter2/18_Type_Casting.html">
            
                
                    <a href="../chapter2/18_Type_Casting.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.18.</b>
                        
                         类型转换
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.19" data-path="chapter2/19_Nested_Types.html">
            
                
                    <a href="../chapter2/19_Nested_Types.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.19.</b>
                        
                         嵌套类型
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.20" data-path="chapter2/20_Extensions.html">
            
                
                    <a href="../chapter2/20_Extensions.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.20.</b>
                        
                         扩展
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter active" data-level="2.21" data-path="chapter2/21_Protocols.html">
            
                
                    <a href="../chapter2/21_Protocols.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.21.</b>
                        
                         协议
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.22" data-path="chapter2/22_Generics.html">
            
                
                    <a href="../chapter2/22_Generics.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.22.</b>
                        
                         泛型
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.23" data-path="chapter2/23_Access Control.html">
            
                
                    <a href="../chapter2/23_Access Control.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.23.</b>
                        
                         权限控制
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.24" data-path="chapter2/24_Advanced_Operators.html">
            
                
                    <a href="../chapter2/24_Advanced_Operators.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.24.</b>
                        
                         高级操作符
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    
        
        <li class="chapter " data-level="3" data-path="chapter3/chapter3.html">
            
                
                    <a href="../chapter3/chapter3.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                         语言参考
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="3.1" data-path="chapter3/01_About_the_Language_Reference.html">
            
                
                    <a href="../chapter3/01_About_the_Language_Reference.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.1.</b>
                        
                         关于语言参考
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.2" data-path="chapter3/02_Lexical_Structure.html">
            
                
                    <a href="../chapter3/02_Lexical_Structure.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.2.</b>
                        
                         词法结构
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.3" data-path="chapter3/03_Types.html">
            
                
                    <a href="../chapter3/03_Types.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.3.</b>
                        
                         类型
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.4" data-path="chapter3/04_Expressions.html">
            
                
                    <a href="../chapter3/04_Expressions.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.4.</b>
                        
                         表达式
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.5" data-path="chapter3/10_Statements.html">
            
                
                    <a href="../chapter3/10_Statements.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.5.</b>
                        
                         语句
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.6" data-path="chapter3/05_Declarations.html">
            
                
                    <a href="../chapter3/05_Declarations.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.6.</b>
                        
                         声明
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.7" data-path="chapter3/06_Attributes.html">
            
                
                    <a href="../chapter3/06_Attributes.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.7.</b>
                        
                         特性
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.8" data-path="chapter3/07_Patterns.html">
            
                
                    <a href="../chapter3/07_Patterns.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.8.</b>
                        
                         模式
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.9" data-path="chapter3/08_Generic_Parameters_and_Arguments.html">
            
                
                    <a href="../chapter3/08_Generic_Parameters_and_Arguments.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.9.</b>
                        
                         泛型参数
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.10" data-path="chapter3/09_Summary_of_the_Grammar.html">
            
                
                    <a href="../chapter3/09_Summary_of_the_Grammar.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.10.</b>
                        
                         语法总结
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    
        
        <li class="chapter " data-level="4" data-path="chapter4/chapter4.html">
            
                
                    <a href="../chapter4/chapter4.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                         苹果官方Blog官方翻译
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="4.1" data-path="chapter4/01_Access_Control.html">
            
                
                    <a href="../chapter4/01_Access_Control.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.1.</b>
                        
                         Access Control 权限控制的黑与白
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4.2" data-path="chapter4/02_Type_Custom.html">
            
                
                    <a href="../chapter4/02_Type_Custom.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.2.</b>
                        
                         造个类型不是梦-白话Swift类型创建
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4.3" data-path="chapter4/03_Ballons.html">
            
                
                    <a href="../chapter4/03_Ballons.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.3.</b>
                        
                         WWDC里面的那个“大炮打气球”
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Generated using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="page-wrapper" tabindex="-1">
                <div class="book-progress">
    <div class="bar">
        <div class="inner" style="width: 59.09090909090909%;min-width: 56.81818181818182%;"></div>
    </div>
    <div class="chapters">
    
        <a href="../index.html" title="Introduction" class="chapter done new-chapter" data-progress="0" style="left: 0%;"></a>
    
        <a href="../chapter1/chapter1.html" title="欢迎使用 Swift" class="chapter done new-chapter" data-progress="1" style="left: 2.272727272727273%;"></a>
    
        <a href="../chapter1/01_Swift.html" title="关于 Swift" class="chapter done " data-progress="1.1" style="left: 4.545454545454546%;"></a>
    
        <a href="../chapter1/02_A_Swift_Tour.html" title="Swift 初见" class="chapter done " data-progress="1.2" style="left: 6.818181818181818%;"></a>
    
        <a href="../chapter1/03_Revision_History.html" title="Swift 版本历史记录" class="chapter done " data-progress="1.3" style="left: 9.090909090909092%;"></a>
    
        <a href="../chapter2/chapter2.html" title="Swift 教程" class="chapter done new-chapter" data-progress="2" style="left: 11.363636363636363%;"></a>
    
        <a href="../chapter2/01_The_Basics.html" title="基础部分" class="chapter done " data-progress="2.1" style="left: 13.636363636363637%;"></a>
    
        <a href="../chapter2/02_Basic_Operators.html" title="基本运算符" class="chapter done " data-progress="2.2" style="left: 15.909090909090908%;"></a>
    
        <a href="../chapter2/03_Strings_and_Characters.html" title="字符串和字符" class="chapter done " data-progress="2.3" style="left: 18.181818181818183%;"></a>
    
        <a href="../chapter2/04_Collection_Types.html" title="集合类型" class="chapter done " data-progress="2.4" style="left: 20.454545454545453%;"></a>
    
        <a href="../chapter2/05_Control_Flow.html" title="控制流" class="chapter done " data-progress="2.5" style="left: 22.727272727272727%;"></a>
    
        <a href="../chapter2/06_Functions.html" title="函数" class="chapter done " data-progress="2.6" style="left: 25%;"></a>
    
        <a href="../chapter2/07_Closures.html" title="闭包" class="chapter done " data-progress="2.7" style="left: 27.272727272727273%;"></a>
    
        <a href="../chapter2/08_Enumerations.html" title="枚举" class="chapter done " data-progress="2.8" style="left: 29.545454545454547%;"></a>
    
        <a href="../chapter2/09_Classes_and_Structures.html" title="类和结构体" class="chapter done " data-progress="2.9" style="left: 31.818181818181817%;"></a>
    
        <a href="../chapter2/10_Properties.html" title="属性" class="chapter done " data-progress="2.10" style="left: 34.09090909090909%;"></a>
    
        <a href="../chapter2/11_Methods.html" title="方法" class="chapter done " data-progress="2.11" style="left: 36.36363636363637%;"></a>
    
        <a href="../chapter2/12_Subscripts.html" title="下标脚本" class="chapter done " data-progress="2.12" style="left: 38.63636363636363%;"></a>
    
        <a href="../chapter2/13_Inheritance.html" title="继承" class="chapter done " data-progress="2.13" style="left: 40.90909090909091%;"></a>
    
        <a href="../chapter2/14_Initialization.html" title="构造过程" class="chapter done " data-progress="2.14" style="left: 43.18181818181818%;"></a>
    
        <a href="../chapter2/15_Deinitialization.html" title="析构过程" class="chapter done " data-progress="2.15" style="left: 45.45454545454545%;"></a>
    
        <a href="../chapter2/16_Automatic_Reference_Counting.html" title="自动引用计数" class="chapter done " data-progress="2.16" style="left: 47.72727272727273%;"></a>
    
        <a href="../chapter2/17_Optional_Chaining.html" title="可选链" class="chapter done " data-progress="2.17" style="left: 50%;"></a>
    
        <a href="../chapter2/18_Type_Casting.html" title="类型转换" class="chapter done " data-progress="2.18" style="left: 52.27272727272727%;"></a>
    
        <a href="../chapter2/19_Nested_Types.html" title="嵌套类型" class="chapter done " data-progress="2.19" style="left: 54.54545454545455%;"></a>
    
        <a href="../chapter2/20_Extensions.html" title="扩展" class="chapter done " data-progress="2.20" style="left: 56.81818181818182%;"></a>
    
        <a href="../chapter2/21_Protocols.html" title="协议" class="chapter done " data-progress="2.21" style="left: 59.09090909090909%;"></a>
    
        <a href="../chapter2/22_Generics.html" title="泛型" class="chapter  " data-progress="2.22" style="left: 61.36363636363637%;"></a>
    
        <a href="../chapter2/23_Access Control.html" title="权限控制" class="chapter  " data-progress="2.23" style="left: 63.63636363636363%;"></a>
    
        <a href="../chapter2/24_Advanced_Operators.html" title="高级操作符" class="chapter  " data-progress="2.24" style="left: 65.9090909090909%;"></a>
    
        <a href="../chapter3/chapter3.html" title="语言参考" class="chapter  new-chapter" data-progress="3" style="left: 68.18181818181819%;"></a>
    
        <a href="../chapter3/01_About_the_Language_Reference.html" title="关于语言参考" class="chapter  " data-progress="3.1" style="left: 70.45454545454545%;"></a>
    
        <a href="../chapter3/02_Lexical_Structure.html" title="词法结构" class="chapter  " data-progress="3.2" style="left: 72.72727272727273%;"></a>
    
        <a href="../chapter3/03_Types.html" title="类型" class="chapter  " data-progress="3.3" style="left: 75%;"></a>
    
        <a href="../chapter3/04_Expressions.html" title="表达式" class="chapter  " data-progress="3.4" style="left: 77.27272727272727%;"></a>
    
        <a href="../chapter3/10_Statements.html" title="语句" class="chapter  " data-progress="3.5" style="left: 79.54545454545455%;"></a>
    
        <a href="../chapter3/05_Declarations.html" title="声明" class="chapter  " data-progress="3.6" style="left: 81.81818181818181%;"></a>
    
        <a href="../chapter3/06_Attributes.html" title="特性" class="chapter  " data-progress="3.7" style="left: 84.0909090909091%;"></a>
    
        <a href="../chapter3/07_Patterns.html" title="模式" class="chapter  " data-progress="3.8" style="left: 86.36363636363636%;"></a>
    
        <a href="../chapter3/08_Generic_Parameters_and_Arguments.html" title="泛型参数" class="chapter  " data-progress="3.9" style="left: 88.63636363636364%;"></a>
    
        <a href="../chapter3/09_Summary_of_the_Grammar.html" title="语法总结" class="chapter  " data-progress="3.10" style="left: 90.9090909090909%;"></a>
    
        <a href="../chapter4/chapter4.html" title="苹果官方Blog官方翻译" class="chapter  new-chapter" data-progress="4" style="left: 93.18181818181819%;"></a>
    
        <a href="../chapter4/01_Access_Control.html" title="Access Control 权限控制的黑与白" class="chapter  " data-progress="4.1" style="left: 95.45454545454545%;"></a>
    
        <a href="../chapter4/02_Type_Custom.html" title="造个类型不是梦-白话Swift类型创建" class="chapter  " data-progress="4.2" style="left: 97.72727272727273%;"></a>
    
        <a href="../chapter4/03_Ballons.html" title="WWDC里面的那个“大炮打气球”" class="chapter  " data-progress="4.3" style="left: 100%;"></a>
    
    </div>
</div>

                <div class="page-inner">
                
                    <section class="normal" id="section-gitbook_48">
                    
                        <blockquote>
<p>翻译：<a href="https://github.com/geek5nan" target="_blank">geek5nan</a><br>校对：<a href="https://github.com/dabing1022" target="_blank">dabing1022</a></p>
</blockquote>
<h1 id="">协议</h1>
<hr>
<p>本页包含内容：</p>
<ul>
<li><a href="#protocol_syntax">协议的语法（Protocol Syntax）</a></li>
<li><a href="#property_requirements">对属性的规定（Property Requirements）</a></li>
<li><a href="#method_requirements">对方法的规定（Method Requirements）</a></li>
<li><a href="#mutating_method_requirements">对突变方法的的规定（Mutating Method Requirements）</a></li>
<li><a href="#protocols_as_types">协议类型（Protocols as Types）</a></li>
<li><a href="#delegation">委托(代理)模式（Delegation）</a></li>
<li><a href="#adding_protocol_conformance_with_an_extension">在扩展中添加协议成员（Adding Protocol Conformance with an Extension）</a></li>
<li><a href="#declaring_protocol_adoption_with_an_extension">通过扩展补充协议声明（Declaring Protocol Adoption with an Extension）</a></li>
<li><a href="#collections_of_protocol_types">集合中的协议类型（Collections of Protocol Types）</a></li>
<li><a href="#protocol_inheritance">协议的继承（Protocol Inheritance）</a></li>
<li><a href="#protocol_composition">协议合成（Protocol Composition）</a></li>
<li><a href="#checking_for_protocol_conformance">检验协议的一致性（Checking for Protocol Conformance）</a></li>
<li><a href="#optional_protocol_requirements">对可选协议的规定（Optional Protocol Requirements）</a></li>
</ul>
<p><code>协议(Protocol)</code>用于定义完成某项任务或功能所必须的方法和属性，协议实际上并不提供这些功能或任务的具体<code>实现(Implementation)</code>--而只用来描述这些实现应该是什么样的。类，结构体，枚举通过提供协议所要求的方法，属性的具体实现来<code>采用(adopt)</code>协议。任意能够满足协议要求的类型被称为协议的<code>遵循者</code>。</p>
<p><code>协议</code>可以要求其<code>遵循者</code>提供特定的实例属性，实例方法，类方法，操作符或下标脚本等。</p>
<p><a name="protocol_syntax"></a></p>
<h2 id="">协议的语法</h2>
<p><code>协议</code>的定义方式与<code>类，结构体，枚举</code>的定义都非常相似，如下所示:</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">SomeProtocol</span> </span>{
    <span class="hljs-comment">// 协议内容</span>
}
</code></pre>
<p>在类型名称后加上<code>协议名称</code>，中间以冒号<code>:</code>分隔即可实现协议；实现多个协议时，各协议之间用逗号<code>,</code>分隔，如下所示:</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SomeStructure</span>: <span class="hljs-title">FirstProtocol</span>, <span class="hljs-title">AnotherProtocol</span> </span>{
    <span class="hljs-comment">// 结构体内容</span>
}
</code></pre>
<p>如果一个类在含有<code>父类</code>的同时也采用了协议，应当把<code>父类</code>放在所有的<code>协议</code>之前，如下所示:</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeClass</span>: <span class="hljs-title">SomeSuperClass</span>, <span class="hljs-title">FirstProtocol</span>, <span class="hljs-title">AnotherProtocol</span> </span>{
    <span class="hljs-comment">// 类的内容</span>
}
</code></pre>
<p><a name="property_requirements"></a></p>
<h2 id="">对属性的规定</h2>
<p>协议可以规定其<code>遵循者</code>提供特定名称与类型的<code>实例属性(instance property)</code>或<code>类属性(type property)</code>，而不管其是<code>存储型属性(stored property)</code>还是<code>计算型属性(calculate property)</code>。此外也可以指定属性是只读的还是可读写的。</p>
<p>如果协议要求属性是可读写的，那么这个属性不能是常量<code>存储型属性</code>或只读<code>计算型属性</code>；如果协议要求属性是只读的(gettable)，那么<code>计算型属性</code>或<code>存储型属性</code>都能满足协议对属性的规定，在你的代码中，即使为只读属性实现了写方法(settable)也依然有效。</p>
<p>协议中的属性经常被加以<code>var</code>前缀声明其为变量属性，在声明后加上<code>{ set get }</code>来表示属性是可读写的，只读的属性则写作<code>{ get }</code>，如下所示:</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">SomeProtocol</span> </span>{
    <span class="hljs-keyword">var</span> mustBeSettable : <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
    <span class="hljs-keyword">var</span> doesNotNeedToBeSettable: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> }
}
</code></pre>
<p>如下所示，通常在协议的定义中使用<code>class</code>前缀表示该属性为类成员；在枚举和结构体实现协议时中，需要使用<code>static</code>关键字作为前缀。</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">AnotherProtocol</span> </span>{
    <span class="hljs-keyword">class</span> <span class="hljs-keyword">var</span> someTypeProperty: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> }
}
</code></pre>
<p>如下所示，这是一个含有一个实例属性要求的协议:</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">FullyNamed</span> </span>{
    <span class="hljs-keyword">var</span> fullName: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }
}
</code></pre>
<p><code>FullyNamed</code>协议定义了任何拥有<code>fullName</code>的类型。它并不指定具体类型，而只是要求类型必须提供一个<code>fullName</code>。任何<code>FullyNamed</code>类型都得有一个只读的<code>fullName</code>属性，类型为<code>String</code>。</p>
<p>如下所示，这是一个实现了<code>FullyNamed</code>协议的简单结构体:</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span>: <span class="hljs-title">FullyNamed</span></span>{
    <span class="hljs-keyword">var</span> fullName: <span class="hljs-type">String</span>
}
<span class="hljs-keyword">let</span> john = <span class="hljs-type">Person</span>(fullName: <span class="hljs-string">"John Appleseed"</span>)
<span class="hljs-comment">//john.fullName 为 "John Appleseed"</span>
</code></pre>
<p>这个例子中定义了一个叫做<code>Person</code>的结构体，用来表示具有指定名字的人。从第一行代码中可以看出，它采用了<code>FullyNamed</code>协议。</p>
<p><code>Person</code>结构体的每一个实例都有一个叫做<code>fullName</code>，<code>String</code>类型的存储型属性，这正好匹配了<code>FullyNamed</code>协议的要求，也就意味着，<code>Person</code>结构体完整的<code>遵循</code>了协议。(如果协议要求未被完全满足,在编译时会报错)</p>
<p>这有一个更为复杂的类，它采用并实现了<code>FullyNamed</code>协议，如下所示:</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Starship</span>: <span class="hljs-title">FullyNamed</span> </span>{
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">prefix</span>: <span class="hljs-type">String</span>?
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>, <span class="hljs-keyword">prefix</span>: <span class="hljs-type">String</span>? = <span class="hljs-built_in">nil</span> ) {
        <span class="hljs-keyword">self</span>.name = name
        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">prefix</span> = <span class="hljs-keyword">prefix</span>
    }
    <span class="hljs-keyword">var</span> fullName: <span class="hljs-type">String</span> {
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">prefix</span> ? <span class="hljs-keyword">prefix</span>! + <span class="hljs-string">" "</span> : <span class="hljs-string">" "</span>) + name
    }
}
<span class="hljs-keyword">var</span> ncc1701 = <span class="hljs-type">Starship</span>(name: <span class="hljs-string">"Enterprise"</span>, <span class="hljs-keyword">prefix</span>: <span class="hljs-string">"USS"</span>)
<span class="hljs-comment">// ncc1701.fullName == "USS Enterprise"</span>
</code></pre>
<p><code>Starship</code>类把<code>fullName</code>属性实现为只读的<code>计算型属性</code>。每一个<code>Starship</code>类的实例都有一个名为<code>name</code>的必备属性和一个名为<code>prefix</code>的可选属性。 当<code>prefix</code>存在时，将<code>prefix</code>插入到<code>name</code>之前来为<code>Starship</code>构建<code>fullName</code>，<code>prefix</code>不存在时，则将直接用<code>name</code>构建<code>fullName</code></p>
<p><a name="method_requirements"></a></p>
<h2 id="">对方法的规定</h2>
<p><code>协议</code>可以要求其<code>遵循者</code>实现某些指定的<code>实例方法</code>或<code>类方法</code>。这些方法作为协议的一部分，像普通的方法一样清晰的放在协议的定义中，而不需要大括号和方法体。</p>
<blockquote>
<p>注意：
协议中的方法支持<code>变长参数(variadic parameter)</code>，不支持<code>参数默认值(default value)</code>。</p>
</blockquote>
<p>如下所示，协议中类方法的定义与类属性的定义相似，在协议定义的方法前置<code>class</code>关键字来表示。当在<code>枚举</code>或<code>结构体</code>实现类方法时，需要使用<code>static</code>关键字来代替。</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">SomeProtocol</span> </span>{
    <span class="hljs-keyword">class</span> <span class="hljs-func"><span class="hljs-keyword">func</span></span> someTypeMethod()
}
</code></pre>
<p>如下所示，定义了含有一个实例方法的的协议。</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">RandomNumberGenerator</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> random() -&gt; <span class="hljs-type">Double</span>
}
</code></pre>
<p><code>RandomNumberGenerator</code>协议要求其<code>遵循者</code>必须拥有一个名为<code>random</code>， 返回值类型为<code>Double</code>的实例方法。 (尽管这里并未指明，但是我们假设返回值在[0，1]区间内)。</p>
<p><code>RandomNumberGenerator</code>协议并不在意每一个随机数是怎样生成的，它只强调这里有一个随机数生成器。</p>
<p>如下所示，下边的是一个遵循了<code>RandomNumberGenerator</code>协议的类。该类实现了一个叫做<em>线性同余生成器(linear congruential generator)</em>的伪随机数算法。</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinearCongruentialGenerator</span>: <span class="hljs-title">RandomNumberGenerator</span> </span>{
    <span class="hljs-keyword">var</span> lastRandom = <span class="hljs-number">42.0</span>
    <span class="hljs-keyword">let</span> m = <span class="hljs-number">139968.0</span>
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">3877.0</span>
    <span class="hljs-keyword">let</span> <span class="hljs-built_in">c</span> = <span class="hljs-number">29573.0</span>
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> random() -&gt; <span class="hljs-type">Double</span> {
        lastRandom = ((lastRandom * a + <span class="hljs-built_in">c</span>) % m)
        <span class="hljs-keyword">return</span> lastRandom / m
    }
}
<span class="hljs-keyword">let</span> generator = <span class="hljs-type">LinearCongruentialGenerator</span>()
<span class="hljs-built_in">println</span>(<span class="hljs-string">"Here's a random number: <span class="hljs-subst">\(generator.random()</span>)"</span>)
<span class="hljs-comment">// 输出 : "Here's a random number: 0.37464991998171"</span>
<span class="hljs-built_in">println</span>(<span class="hljs-string">"And another one: <span class="hljs-subst">\(generator.random()</span>)"</span>)
<span class="hljs-comment">// 输出 : "And another one: 0.729023776863283"</span>
</code></pre>
<p><a name="mutating_method_requirements"></a></p>
<h2 id="">对突变方法的规定</h2>
<p>有时不得不在方法中更改实例的所属类型。在基于<code>值类型(value types)</code>(结构体，枚举)的实例方法中，将<code>mutating</code>关键字作为函数的前缀，写在<code>func</code>之前，表示可以在该方法中修改实例及其属性的所属类型。这一过程在<a href="1">Modifyting Value Types from Within Instance Methods</a>章节中有详细描述。</p>
<p>如果协议中的实例方法打算改变其<code>遵循者</code>实例的类型，那么在协议定义时需要在方法前加<code>mutating</code>关键字，才能使<code>结构体，枚举</code>来采用并满足协议中对方法的规定。</p>
<blockquote>
<p>注意: 
用<code>类</code>实现协议中的<code>mutating</code>方法时，不用写<code>mutating</code>关键字;用<code>结构体</code>，<code>枚举</code>实现协议中的<code>mutating</code>方法时，必须写<code>mutating</code>关键字。</p>
</blockquote>
<p>如下所示，<code>Togglable</code>协议含有名为<code>toggle</code>的突变实例方法。根据名称推测，<code>toggle</code>方法应该是用于切换或恢复其<code>遵循者</code>实例或其属性的类型。</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Togglable</span> </span>{
    <span class="hljs-keyword">mutating</span> <span class="hljs-func"><span class="hljs-keyword">func</span></span> toggle()
}
</code></pre>
<p>当使用<code>枚举</code>或<code>结构体</code>来实现<code>Togglabl</code>协议时，需要提供一个带有<code>mutating</code>前缀的<code>toggle</code>方法。</p>
<p>如下所示，<code>OnOffSwitch</code>枚举<code>遵循</code>了<code>Togglable</code>协议，<code>On</code>，<code>Off</code>两个成员用于表示当前状态。枚举的<code>toggle</code>方法被标记为<code>mutating</code>，用以匹配<code>Togglabel</code>协议的规定。</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">OnOffSwitch</span>: <span class="hljs-title">Togglable</span> </span>{
    <span class="hljs-keyword">case</span> <span class="hljs-type">Off</span>, <span class="hljs-type">On</span>
    <span class="hljs-keyword">mutating</span> <span class="hljs-func"><span class="hljs-keyword">func</span></span> toggle() {
        <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
        <span class="hljs-keyword">case</span> <span class="hljs-type">Off</span>:
            <span class="hljs-keyword">self</span> = <span class="hljs-type">On</span>
        <span class="hljs-keyword">case</span> <span class="hljs-type">On</span>:
            <span class="hljs-keyword">self</span> = <span class="hljs-type">Off</span>
        }
    }
}
<span class="hljs-keyword">var</span> lightSwitch = <span class="hljs-type">OnOffSwitch</span>.<span class="hljs-type">Off</span>
lightSwitch.toggle()
<span class="hljs-comment">//lightSwitch 现在的值为 .On</span>
</code></pre>
<p><a name="protocols_as_types"></a></p>
<h2 id="">协议类型</h2>
<p>尽管<code>协议</code>本身并不实现任何功能，但是<code>协议</code>可以被当做类型来使用。</p>
<p>使用场景:  </p>
<ul>
<li><code>协议类型</code>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li><code>协议类型</code>作为常量、变量或属性的类型</li>
<li><code>协议类型</code>作为数组、字典或其他容器中的元素类型</li>
</ul>
<blockquote>
<p>注意: 协议是一种类型，因此协议类型的名称应与其他类型(Int，Double，String)的写法相同，使用驼峰式写法</p>
</blockquote>
<p>如下所示，这个示例中将协议当做类型来使用</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dice</span> </span>{
    <span class="hljs-keyword">let</span> sides: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">let</span> generator: <span class="hljs-type">RandomNumberGenerator</span>
    <span class="hljs-keyword">init</span>(sides: <span class="hljs-type">Int</span>, generator: <span class="hljs-type">RandomNumberGenerator</span>) {
        <span class="hljs-keyword">self</span>.sides = sides
        <span class="hljs-keyword">self</span>.generator = generator
    }
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> roll() -&gt; <span class="hljs-type">Int</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-type">Int</span>(generator.random() * <span class="hljs-type">Double</span>(sides)) + <span class="hljs-number">1</span>
    }
}
</code></pre>
<p>例子中又一个<code>Dice</code>类，用来代表桌游中的拥有N个面的骰子。<code>Dice</code>的实例含有<code>sides</code>和<code>generator</code>两个属性，前者是整型，用来表示骰子有几个面，后者为骰子提供一个随机数生成器。</p>
<p> <code>generator</code>属性的类型为<code>RandomNumberGenerator</code>，因此任何遵循了<code>RandomNumberGenerator</code>协议的类型的实例都可以赋值给<code>generator</code>，除此之外，无其他要求。</p>
<p><code>Dice</code>类中也有一个<code>构造器(initializer)</code>，用来进行初始化操作。构造器中含有一个名为<code>generator</code>，类型为<code>RandomNumberGenerator</code>的形参。在调用构造方法时创建<code>Dice</code>的实例时，可以传入任何遵循<code>RandomNumberGenerator</code>协议的实例给generator。</p>
<p><code>Dice</code>类也提供了一个名为<code>roll</code>的实例方法用来模拟骰子的面值。它先使用<code>generator</code>的<code>random</code>方法来创建一个[0-1]区间内的随机数种子，然后加工这个随机数种子生成骰子的面值。generator被认为是遵循了<code>RandomNumberGenerator</code>的类型，因而保证了<code>random</code>方法可以被调用。</p>
<p>如下所示，这里展示了如何使用<code>LinearCongruentialGenerator</code>的实例作为随机数生成器创建一个六面骰子:</p>
<pre><code class="lang-swift"><span class="hljs-keyword">var</span> d6 = <span class="hljs-type">Dice</span>(sides: <span class="hljs-number">6</span>,generator: <span class="hljs-type">LinearCongruentialGenerator</span>())
<span class="hljs-keyword">for</span> <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>...<span class="hljs-number">5</span> {
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"Random dice roll is <span class="hljs-subst">\(d6.roll()</span>)"</span>)
}
<span class="hljs-comment">//输出结果</span>
<span class="hljs-comment">//Random dice roll is 3</span>
<span class="hljs-comment">//Random dice roll is 5</span>
<span class="hljs-comment">//Random dice roll is 4</span>
<span class="hljs-comment">//Random dice roll is 5</span>
<span class="hljs-comment">//Random dice roll is 4</span>
</code></pre>
<p><a name="delegation"></a></p>
<h2 id="">委托(代理)模式</h2>
<p>委托是一种设计模式(<em>译者注: 想起了那年 UITableViewDelegate 中的奔跑，那是我逝去的Objective-C。。。</em>)，它允许<code>类</code>或<code>结构体</code>将一些需要它们负责的功能<code>交由(委托)</code>给其他的类型的实例。</p>
<p>委托模式的实现很简单: 定义<code>协议</code>来<code>封装</code>那些需要被委托的<code>函数和方法</code>， 使其<code>遵循者</code>拥有这些被委托的<code>函数和方法</code>。</p>
<p>委托模式可以用来响应特定的动作或接收外部数据源提供的数据，而无需要知道外部数据源的所属类型(<em>译者注:只要求外部数据源<code>遵循</code>某协议</em>)。</p>
<p>下文是两个基于骰子游戏的协议: </p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">DiceGame</span> </span>{
    <span class="hljs-keyword">var</span> dice: <span class="hljs-type">Dice</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> play()
}

<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">DiceGameDelegate</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> gameDidStart(game: <span class="hljs-type">DiceGame</span>)
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> game(game: <span class="hljs-type">DiceGame</span>, didStartNewTurnWithDiceRoll diceRoll:<span class="hljs-type">Int</span>)
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> gameDidEnd(game: <span class="hljs-type">DiceGame</span>)
}
</code></pre>
<p><code>DiceGame</code>协议可以在任意含有骰子的游戏中实现，<code>DiceGameDelegate</code>协议可以用来追踪<code>DiceGame</code>的游戏过程</p>
<p>如下所示，<code>SnakesAndLadders</code>是<code>Snakes and Ladders</code>(译者注:<a href="2">Control Flow</a>章节有该游戏的详细介绍)游戏的新版本。新版本使用<code>Dice</code>作为骰子，并且实现了<code>DiceGame</code>和<code>DiceGameDelegate</code>协议，后者用来记录游戏的过程:</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SnakesAndLadders</span>: <span class="hljs-title">DiceGame</span> </span>{
    <span class="hljs-keyword">let</span> finalSquare = <span class="hljs-number">25</span>
    <span class="hljs-keyword">let</span> dice = <span class="hljs-type">Dice</span>(sides: <span class="hljs-number">6</span>, generator: <span class="hljs-type">LinearCongruentialGenerator</span>())
    <span class="hljs-keyword">var</span> square = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> board: <span class="hljs-type">Int</span>[]
    <span class="hljs-keyword">init</span>() {
        board = <span class="hljs-type">Int</span>[](<span class="hljs-built_in">count</span>: finalSquare + <span class="hljs-number">1</span>, repeatedValue: <span class="hljs-number">0</span>)
        board[<span class="hljs-number">03</span>] = +<span class="hljs-number">08</span>; board[<span class="hljs-number">06</span>] = +<span class="hljs-number">11</span>; board[<span class="hljs-number">09</span>] = +<span class="hljs-number">09</span>; board[<span class="hljs-number">10</span>] = +<span class="hljs-number">02</span>
        board[<span class="hljs-number">14</span>] = -<span class="hljs-number">10</span>; board[<span class="hljs-number">19</span>] = -<span class="hljs-number">11</span>; board[<span class="hljs-number">22</span>] = -<span class="hljs-number">02</span>; board[<span class="hljs-number">24</span>] = -<span class="hljs-number">08</span>
    }
     <span class="hljs-keyword">var</span> delegate: <span class="hljs-type">DiceGameDelegate</span>?
     <span class="hljs-func"><span class="hljs-keyword">func</span></span> play() {
         square = <span class="hljs-number">0</span>
         delegate?.gameDidStart(<span class="hljs-keyword">self</span>)
         gameLoop: <span class="hljs-keyword">while</span> square != finalSquare {
             <span class="hljs-keyword">let</span> diceRoll = dice.roll()
             delegate?.game(<span class="hljs-keyword">self</span>,didStartNewTurnWithDiceRoll: diceRoll)
             <span class="hljs-keyword">switch</span> square + diceRoll {
             <span class="hljs-keyword">case</span> finalSquare:
                 <span class="hljs-keyword">break</span> gameLoop
             <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> newSquare <span class="hljs-keyword">where</span> newSquare &gt; finalSquare:
                 <span class="hljs-keyword">continue</span> gameLoop
             <span class="hljs-keyword">default</span>:
             square += diceRoll
             square += board[square]
             }
         }
         delegate?.gameDidEnd(<span class="hljs-keyword">self</span>)
     }
}
</code></pre>
<p>这个版本的游戏封装到了<code>SnakesAndLadders</code>类中，该类采用了<code>DiceGame</code>协议，并且提供了<code>dice</code>属性和<code>play</code>实例方法用来<code>遵循</code>协议。(<code>dice</code>属性在构造之后就不在改变，且协议只要求<code>dice</code>为只读的，因此将<code>dice</code>声明为常量属性。)</p>
<p>在<code>SnakesAndLadders</code>类的<code>构造器(initializer)</code>初始化游戏。所有的游戏逻辑被转移到了<code>play</code>方法中，<code>play</code>方法使用协议规定的<code>dice</code>属性提供骰子摇出的值。</p>
<blockquote>
<p>注意:<code>delegate</code>并不是游戏的必备条件，因此<code>delegate</code>被定义为遵循<code>DiceGameDelegate</code>协议的可选属性，<code>delegate</code>使用<code>nil</code>作为初始值。</p>
</blockquote>
<p><code>DicegameDelegate</code>协议提供了三个方法用来追踪游戏过程。被放置于游戏的逻辑中，即<code>play()</code>方法内。分别在游戏开始时，新一轮开始时，游戏结束时被调用。</p>
<p>因为<code>delegate</code>是一个遵循<code>DiceGameDelegate</code>的可选属性，因此在<code>play()</code>方法中使用了<code>可选链</code>来调用委托方法。 若<code>delegate</code>属性为<code>nil</code>， 则delegate所调用的方法失效。若<code>delegate</code>不为<code>nil</code>，则方法能够被调用</p>
<p>如下所示，<code>DiceGameTracker</code>遵循了<code>DiceGameDelegate</code>协议</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiceGameTracker</span>: <span class="hljs-title">DiceGameDelegate</span> </span>{
    <span class="hljs-keyword">var</span> numberOfTurns = <span class="hljs-number">0</span>
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> gameDidStart(game: <span class="hljs-type">DiceGame</span>) {
        numberOfTurns = <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> game <span class="hljs-keyword">is</span> <span class="hljs-type">SnakesAndLadders</span> {
            <span class="hljs-built_in">println</span>(<span class="hljs-string">"Started a new game of Snakes and Ladders"</span>)
        }
        <span class="hljs-built_in">println</span>(<span class="hljs-string">"The game is using a <span class="hljs-subst">\(game.dice.sides)</span>-sided dice"</span>)
    }
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> game(game: <span class="hljs-type">DiceGame</span>, didStartNewTurnWithDiceRoll diceRoll: <span class="hljs-type">Int</span>) {
        ++numberOfTurns
        <span class="hljs-built_in">println</span>(<span class="hljs-string">"Rolled a <span class="hljs-subst">\(diceRoll)</span>"</span>)
    }
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> gameDidEnd(game: <span class="hljs-type">DiceGame</span>) {
        <span class="hljs-built_in">println</span>(<span class="hljs-string">"The game lasted for <span class="hljs-subst">\(numberOfTurns)</span> turns"</span>)
    }
}
</code></pre>
<p><code>DiceGameTracker</code>实现了<code>DiceGameDelegate</code>协议规定的三个方法，用来记录游戏已经进行的轮数。 当游戏开始时，<code>numberOfTurns</code>属性被赋值为0; 在每新一轮中递加; 游戏结束后，输出打印游戏的总轮数。</p>
<p><code>gameDidStart</code>方法从<code>game</code>参数获取游戏信息并输出。<code>game</code>在方法中被当做<code>DiceGame</code>类型而不是<code>SnakeAndLadders</code>类型，所以方法中只能访问<code>DiceGame</code>协议中的成员。当然了，这些方法也可以在类型转换之后调用。在上例代码中，通过<code>is</code>操作符检查<code>game</code>是否为 <code>SnakesAndLadders</code>类型的实例，如果是，则打印出相应的内容。</p>
<p>无论当前进行的是何种游戏，<code>game</code>都遵循<code>DiceGame</code>协议以确保<code>game</code>含有<code>dice</code>属性，因此在<code>gameDidStart</code>方法中可以通过传入的<code>game</code>参数来访问<code>dice</code>属性，进而打印出<code>dice</code>的<code>sides</code>属性的值。</p>
<p><code>DiceGameTracker</code>的运行情况，如下所示:</p>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> tracker = <span class="hljs-type">DiceGameTracker</span>()
<span class="hljs-keyword">let</span> game = <span class="hljs-type">SnakesAndLadders</span>()
game.delegate = tracker
game.play()
<span class="hljs-comment">// Started a new game of Snakes and Ladders</span>
<span class="hljs-comment">// The game is using a 6-sided dice</span>
<span class="hljs-comment">// Rolled a 3</span>
<span class="hljs-comment">// Rolled a 5</span>
<span class="hljs-comment">// Rolled a 4</span>
<span class="hljs-comment">// Rolled a 5</span>
<span class="hljs-comment">// The game lasted for 4 turns</span>
</code></pre>
<p><a name="adding_protocol_conformance_with_an_extension"></a></p>
<h2 id="">在扩展中添加协议成员</h2>
<p>即便无法修改源代码，依然可以通过<code>扩展(Extension)</code>来扩充已存在类型(<em>译者注: 类，结构体，枚举等</em>)。<code>扩展</code>可以为已存在的类型添加<code>属性</code>，<code>方法</code>，<code>下标脚本</code>，<code>协议</code>等成员。详情请在<a href="4">扩展</a>章节中查看。</p>
<blockquote>
<p>注意: 通过<code>扩展</code>为已存在的类型<code>遵循</code>协议时，该类型的所有实例也会随之添加协议中的方法</p>
</blockquote>
<p><code>TextRepresentable</code>协议含有一个<code>asText</code>，如下所示：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TextRepresentable</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> asText() -&gt; <span class="hljs-type">String</span>
}
</code></pre>
<p>通过<code>扩展</code>为上一节中提到的<code>Dice</code>类遵循<code>TextRepresentable</code>协议</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Dice</span>: <span class="hljs-title">TextRepresentable</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> asText() -&gt; <span class="hljs-type">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"A <span class="hljs-subst">\(sides)</span>-sided dice"</span>
    }
}
</code></pre>
<p>从现在起，<code>Dice</code>类型的实例可被当作<code>TextRepresentable</code>类型：</p>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> d12 = <span class="hljs-type">Dice</span>(sides: <span class="hljs-number">12</span>,generator: <span class="hljs-type">LinearCongruentialGenerator</span>())
<span class="hljs-built_in">println</span>(d12.asText())
<span class="hljs-comment">// 输出 "A 12-sided dice"</span>
</code></pre>
<p><code>SnakesAndLadders</code>类也可以通过<code>扩展</code>的方式来遵循协议：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">SnakesAndLadders</span>: <span class="hljs-title">TextRepresentable</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> asText() -&gt; <span class="hljs-type">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"A game of Snakes and Ladders with <span class="hljs-subst">\(finalSquare)</span> squares"</span>
    }
}
<span class="hljs-built_in">println</span>(game.asText())
<span class="hljs-comment">// 输出 "A game of Snakes and Ladders with 25 squares"</span>
</code></pre>
<p><a name="declaring_protocol_adoption_with_an_extension"></a></p>
<h2 id="">通过扩展补充协议声明</h2>
<p>当一个类型已经实现了协议中的所有要求，却没有声明时，可以通过<code>扩展</code>来补充协议声明:</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Hamster</span> </span>{
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> asText() -&gt; <span class="hljs-type">String</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"A hamster named <span class="hljs-subst">\(name)</span>"</span>
    }
}
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Hamster</span>: <span class="hljs-title">TextRepresentable</span> </span>{}
</code></pre>
<p>从现在起，<code>Hamster</code>的实例可以作为<code>TextRepresentable</code>类型使用</p>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> simonTheHamster = <span class="hljs-type">Hamster</span>(name: <span class="hljs-string">"Simon"</span>)
<span class="hljs-keyword">let</span> somethingTextRepresentable: <span class="hljs-type">TextRepresentable</span> = simonTheHamster
<span class="hljs-built_in">println</span>(somethingTextRepresentable.asText())
<span class="hljs-comment">// 输出 "A hamster named Simon"</span>
</code></pre>
<blockquote>
<p>注意: 即时满足了协议的所有要求，类型也不会自动转变，因此你必须为它做出明显的协议声明</p>
</blockquote>
<p><a name="collections_of_protocol_types"></a></p>
<h2 id="">集合中的协议类型</h2>
<p>协议类型可以被集合使用，表示集合中的元素均为协议类型:</p>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> things: <span class="hljs-type">TextRepresentable</span>[] = [game,d12,simonTheHamster]
</code></pre>
<p>如下所示，<code>things</code>数组可以被直接遍历，并调用其中元素的<code>asText()</code>函数:</p>
<pre><code class="lang-swift"><span class="hljs-keyword">for</span> thing <span class="hljs-keyword">in</span> things {
    <span class="hljs-built_in">println</span>(thing.asText())
}
<span class="hljs-comment">// A game of Snakes and Ladders with 25 squares</span>
<span class="hljs-comment">// A 12-sided dice</span>
<span class="hljs-comment">// A hamster named Simon</span>
</code></pre>
<p><code>thing</code>被当做是<code>TextRepresentable</code>类型而不是<code>Dice</code>，<code>DiceGame</code>，<code>Hamster</code>等类型。因此能且仅能调用<code>asText</code>方法</p>
<p><a name="protocol_inheritance"></a></p>
<h2 id="">协议的继承</h2>
<p>协议能够继承一到多个其他协议。语法与类的继承相似，多个协议间用逗号<code>，</code>分隔</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">InheritingProtocol</span>: <span class="hljs-title">SomeProtocol</span>, <span class="hljs-title">AnotherProtocol</span> </span>{
    <span class="hljs-comment">// 协议定义</span>
}
</code></pre>
<p>如下所示，<code>PrettyTextRepresentable</code>协议继承了<code>TextRepresentable</code>协议</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">PrettyTextRepresentable</span>: <span class="hljs-title">TextRepresentable</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> asPrettyText() -&gt; <span class="hljs-type">String</span>
}
</code></pre>
<p>遵循<code>PrettyTextRepresentable</code>协议的同时，也需要遵循<code>TextRepresentable</code>协议。</p>
<p>如下所示，用<code>扩展</code>为<code>SnakesAndLadders</code>遵循<code>PrettyTextRepresentable</code>协议:</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">SnakesAndLadders</span>: <span class="hljs-title">PrettyTextRepresentable</span> </span>{
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> asPrettyText() -&gt; <span class="hljs-type">String</span> {
        <span class="hljs-keyword">var</span> output = asText() + <span class="hljs-string">":\n"</span>
        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>...finalSquare {
            <span class="hljs-keyword">switch</span> board[index] {
                <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> ladder <span class="hljs-keyword">where</span> ladder &gt; <span class="hljs-number">0</span>:
                output += <span class="hljs-string">"▲ "</span>
            <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> snake <span class="hljs-keyword">where</span> snake &lt; <span class="hljs-number">0</span>:
                output += <span class="hljs-string">"▼ "</span>
            <span class="hljs-keyword">default</span>:
                output += <span class="hljs-string">"○ "</span>
            }
        }
        <span class="hljs-keyword">return</span> output
    }
}
</code></pre>
<p>在<code>for in</code>中迭代出了<code>board</code>数组中的每一个元素:</p>
<ul>
<li>当从数组中迭代出的元素的值大于0时，用<code>▲</code>表示</li>
<li>当从数组中迭代出的元素的值小于0时，用<code>▼</code>表示</li>
<li>当从数组中迭代出的元素的值等于0时，用<code>○</code>表示</li>
</ul>
<p>任意<code>SankesAndLadders</code>的实例都可以使用<code>asPrettyText()</code>方法。</p>
<pre><code class="lang-swift"><span class="hljs-built_in">println</span>(game.asPrettyText())
<span class="hljs-comment">// A game of Snakes and Ladders with 25 squares:</span>
<span class="hljs-comment">// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</span>
</code></pre>
<p><a name="protocol_composition"></a></p>
<h2 id="">协议合成</h2>
<p>一个协议可由多个协议采用<code>protocol&lt;SomeProtocol， AnotherProtocol&gt;</code>这样的格式进行组合，称为<code>协议合成(protocol composition)</code>。</p>
<p>举个例子：</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Named</span> </span>{
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }
}
<span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Aged</span> </span>{
    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> }
}
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span>: <span class="hljs-title">Named</span>, <span class="hljs-title">Aged</span> </span>{
    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span>
}
<span class="hljs-func"><span class="hljs-keyword">func</span></span> wishHappyBirthday(celebrator: <span class="hljs-class"><span class="hljs-keyword">protocol</span>&lt;<span class="hljs-title">Named</span>, <span class="hljs-title">Aged</span>&gt;) </span>{
    <span class="hljs-built_in">println</span>(<span class="hljs-string">"Happy birthday <span class="hljs-subst">\(celebrator.name)</span> - you're <span class="hljs-subst">\(celebrator.age)</span>!"</span>)
}
<span class="hljs-keyword">let</span> birthdayPerson = <span class="hljs-type">Person</span>(name: <span class="hljs-string">"Malcolm"</span>, age: <span class="hljs-number">21</span>)
wishHappyBirthday(birthdayPerson)
<span class="hljs-comment">// 输出 "Happy birthday Malcolm - you're 21!</span>
</code></pre>
<p><code>Named</code>协议包含<code>String</code>类型的<code>name</code>属性;<code>Aged</code>协议包含<code>Int</code>类型的<code>age</code>属性。<code>Person</code>结构体<code>遵循</code>了这两个协议。</p>
<p><code>wishHappyBirthday</code>函数的形参<code>celebrator</code>的类型为<code>protocol&lt;Named，Aged&gt;</code>。可以传入任意<code>遵循</code>这两个协议的类型的实例</p>
<blockquote>
<p>注意: <code>协议合成</code>并不会生成一个新协议类型，而是将多个协议合成为一个临时的协议，超出范围后立即失效。</p>
</blockquote>
<p><a name="checking_for_protocol_conformance"></a></p>
<h2 id="">检验协议的一致性</h2>
<p>使用<code>is</code>和<code>as</code>操作符来检查协议的一致性或转化协议类型。检查和转化的语法和之前相同(<em>详情查看<a href="5">Typy Casting章节</a></em>):</p>
<ul>
<li><code>is</code>操作符用来检查实例是否<code>遵循</code>了某个<code>协议</code>。 </li>
<li><code>as?</code>返回一个可选值，当实例<code>遵循</code>协议时，返回该协议类型;否则返回<code>nil</code></li>
<li><code>as</code>用以强制向下转型。  </li>
</ul>
<pre><code class="lang-swift"><span class="hljs-preprocessor">@objc</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">HasArea</span> </span>{
    <span class="hljs-keyword">var</span> area: <span class="hljs-type">Double</span> { <span class="hljs-keyword">get</span> }
}
</code></pre>
<blockquote>
<p>注意: <code>@objc</code>用来表示协议是可选的，也可以用来表示暴露给<code>Objective-C</code>的代码，此外，<code>@objc</code>型协议只对<code>类</code>有效，因此只能在<code>类</code>中检查协议的一致性。详情查看<em><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank">Using Siwft with Cocoa and Objectivei-c</a></em>。</p>
</blockquote>
<p>如下所示，定义了<code>Circle</code>和<code>Country</code>类，它们都遵循了<code>HasArea</code>协议</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>: <span class="hljs-title">HasArea</span> </span>{
    <span class="hljs-keyword">let</span> pi = <span class="hljs-number">3.1415927</span>
    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">var</span> area: <span class="hljs-type">Double</span> { <span class="hljs-keyword">return</span> pi * radius * radius }
    <span class="hljs-keyword">init</span>(radius: <span class="hljs-type">Double</span>) { <span class="hljs-keyword">self</span>.radius = radius }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Country</span>: <span class="hljs-title">HasArea</span> </span>{
    <span class="hljs-keyword">var</span> area: <span class="hljs-type">Double</span>
    <span class="hljs-keyword">init</span>(area: <span class="hljs-type">Double</span>) { <span class="hljs-keyword">self</span>.area = area }
}
</code></pre>
<p><code>Circle</code>类把<code>area</code>实现为基于<code>存储型属性</code>radius的<code>计算型属性</code>，<code>Country</code>类则把<code>area</code>实现为<code>存储型属性</code>。这两个类都<code>遵循</code>了<code>HasArea</code>协议。</p>
<p>如下所示，Animal是一个没有实现<code>HasArea</code>协议的类</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
    <span class="hljs-keyword">var</span> legs: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">init</span>(legs: <span class="hljs-type">Int</span>) { <span class="hljs-keyword">self</span>.legs = legs }
}
</code></pre>
<p><code>Circle，Country，Animal</code>并没有一个相同的基类，因而采用<code>AnyObject</code>类型的数组来装载在他们的实例，如下所示:</p>
<pre><code class="lang-swift"><span class="hljs-keyword">let</span> objects: <span class="hljs-type">AnyObject</span>[] = [
    <span class="hljs-type">Circle</span>(radius: <span class="hljs-number">2.0</span>),
    <span class="hljs-type">Country</span>(area: <span class="hljs-number">243_610</span>),
    <span class="hljs-type">Animal</span>(legs: <span class="hljs-number">4</span>)
]
</code></pre>
<p><code>objects</code>数组使用字面量初始化，数组包含一个<code>radius</code>为2。0的<code>Circle</code>的实例，一个保存了英国面积的<code>Country</code>实例和一个<code>legs</code>为4的<code>Animal</code>实例。</p>
<p>如下所示，<code>objects</code>数组可以被迭代，对迭代出的每一个元素进行检查，看它是否遵循了<code>HasArea</code>协议:</p>
<pre><code class="lang-swift"><span class="hljs-keyword">for</span> object <span class="hljs-keyword">in</span> objects {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> objectWithArea = object <span class="hljs-keyword">as</span>? <span class="hljs-type">HasArea</span> {
        <span class="hljs-built_in">println</span>(<span class="hljs-string">"Area is <span class="hljs-subst">\(objectWithArea.area)</span>"</span>)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">println</span>(<span class="hljs-string">"Something that doesn't have an area"</span>)
    }
}
<span class="hljs-comment">// Area is 12.5663708</span>
<span class="hljs-comment">// Area is 243610.0</span>
<span class="hljs-comment">// Something that doesn't have an area</span>
</code></pre>
<p>当迭代出的元素遵循<code>HasArea</code>协议时，通过<code>as?</code>操作符将其<code>可选绑定(optional binding)</code>到<code>objectWithArea</code>常量上。<code>objectWithArea</code>是<code>HasArea</code>协议类型的实例，因此<code>area</code>属性是可以被访问和打印的。</p>
<p><code>objects</code>数组中元素的类型并不会因为<code>向下转型</code>而改变，它们仍然是<code>Circle</code>，<code>Country</code>，<code>Animal</code>类型。然而，当它们被赋值给<code>objectWithArea</code>常量时，则只被视为<code>HasArea</code>类型，因此只有<code>area</code>属性能够被访问。</p>
<p><a name="optional_protocol_requirements"></a></p>
<h2 id="">对可选协议的规定</h2>
<p>可选协议含有可选成员，其<code>遵循者</code>可以选择是否实现这些成员。在协议中使用<code>@optional</code>关键字作为前缀来定义可选成员。</p>
<p>可选协议在调用时使用<code>可选链</code>，详细内容在<a href="7">Optional Chaning</a>章节中查看。</p>
<p>像<code>someOptionalMethod?(someArgument)</code>这样，你可以在可选方法名称后加上<code>?</code>来检查该方法是否被实现。<code>可选方法</code>和<code>可选属性</code>都会返回一个<code>可选值(optional value)</code>，当其不可访问时，<code>?</code>之后语句不会执行，并整体返回<code>nil</code></p>
<blockquote>
<p>注意: 可选协议只能在含有<code>@objc</code>前缀的协议中生效。且<code>@objc</code>的协议只能被<code>类</code>遵循</p>
</blockquote>
<p>如下所示，<code>Counter</code>类使用含有两个可选成员的<code>CounterDataSource</code>协议类型的外部数据源来提供<code>增量值(increment amount)</code></p>
<pre><code class="lang-swift"><span class="hljs-preprocessor">@objc</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">CounterDataSource</span> </span>{
    <span class="hljs-preprocessor">@optional</span> <span class="hljs-func"><span class="hljs-keyword">func</span></span> incrementForCount(<span class="hljs-built_in">count</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>
    <span class="hljs-preprocessor">@optional</span> <span class="hljs-keyword">var</span> fixedIncrement: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> }
}
</code></pre>
<p><code>CounterDataSource</code>含有<code>incrementForCount</code>的<code>可选方法</code>和<code>fiexdIncrement</code>的<code>可选属性</code>，它们使用了不同的方法来从数据源中获取合适的增量值。</p>
<blockquote>
<p>注意: <code>CounterDataSource</code>中的属性和方法都是可选的，因此可以在类中声明但不实现这些成员，尽管技术上允许这样做，不过最好不要这样写。</p>
</blockquote>
<p><code>Counter</code>类含有<code>CounterDataSource?</code>类型的可选属性<code>dataSource</code>，如下所示:</p>
<pre><code class="lang-swift"><span class="hljs-preprocessor">@objc</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> </span>{
    <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> dataSource: <span class="hljs-type">CounterDataSource</span>?
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> increment() {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> amount = dataSource?.incrementForCount?(<span class="hljs-built_in">count</span>) {
            <span class="hljs-built_in">count</span> += amount
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> amount = dataSource?.fixedIncrement? {
            <span class="hljs-built_in">count</span> += amount
        }
    }
}
</code></pre>
<p><code>count</code>属性用于存储当前的值，<code>increment</code>方法用来为<code>count</code>赋值。</p>
<p><code>increment</code>方法通过<code>可选链</code>，尝试从两种<code>可选成员</code>中获取<code>count</code>。</p>
<ol>
<li><p>由于<code>dataSource</code>可能为<code>nil</code>，因此在<code>dataSource</code>后边加上了<code>?</code>标记来表明只在<code>dataSource</code>非空时才去调用<code>incrementForCount</code>方法。</p>
</li>
<li><p>即使<code>dataSource</code>存在，但是也无法保证其是否实现了<code>incrementForCount</code>方法，因此在<code>incrementForCount</code>方法后边也加有<code>?</code>标记</p>
</li>
</ol>
<p>在调用<code>incrementForCount</code>方法后，<code>Int</code>型<code>可选值</code>通过<code>可选绑定(optional binding)</code>自动拆包并赋值给常量<code>amount</code>。</p>
<p>当<code>incrementForCount</code>不能被调用时，尝试使用可选属性<code>fixedIncrement</code>来代替。</p>
<p><code>ThreeSource</code>实现了<code>CounterDataSource</code>协议，如下所示:</p>
<pre><code>class ThreeSource: CounterDataSource {
    let fixedIncrement = 3
}
</code></pre><p>使用<code>ThreeSource</code>作为数据源开实例化一个<code>Counter</code>:</p>
<pre><code class="lang-swift"><span class="hljs-keyword">var</span> counter = <span class="hljs-type">Counter</span>()
counter.dataSource = <span class="hljs-type">ThreeSource</span>()
<span class="hljs-keyword">for</span> <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>...<span class="hljs-number">4</span> {
    counter.increment()
    <span class="hljs-built_in">println</span>(counter.<span class="hljs-built_in">count</span>)
}
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 6</span>
<span class="hljs-comment">// 9</span>
<span class="hljs-comment">// 12</span>
</code></pre>
<p><code>TowardsZeroSource</code>实现了<code>CounterDataSource</code>协议中的<code>incrementForCount</code>方法，如下所示:</p>
<pre><code class="lang-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TowardsZeroSource</span>: <span class="hljs-title">CounterDataSource</span> </span>{
<span class="hljs-func"><span class="hljs-keyword">func</span></span> incrementForCount(<span class="hljs-built_in">count</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> {
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">count</span> == <span class="hljs-number">0</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">count</span> &lt; <span class="hljs-number">0</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
        }
    }
}
</code></pre>
<p>下边是执行的代码：</p>
<pre><code class="lang-swift">counter.<span class="hljs-built_in">count</span> = -<span class="hljs-number">4</span>
counter.dataSource = <span class="hljs-type">TowardsZeroSource</span>()
<span class="hljs-keyword">for</span> <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>...<span class="hljs-number">5</span> {
    counter.increment()
    <span class="hljs-built_in">println</span>(counter.<span class="hljs-built_in">count</span>)
}
<span class="hljs-comment">// -3</span>
<span class="hljs-comment">// -2</span>
<span class="hljs-comment">// -1</span>
<span class="hljs-comment">// 0</span>
<span class="hljs-comment">// 0</span>
</code></pre>

                    
                    </section>
                
                </div>
            </div>
        </div>

        
        <a href="../chapter2/20_Extensions.html" class="navigation navigation-prev " aria-label="Previous page: 扩展"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../chapter2/22_Generics.html" class="navigation navigation-next " aria-label="Next page: 泛型"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="../gitbook/jsrepl/jsrepl.js" id="jsrepl-script"></script>
<script src="../gitbook/app.js"></script>

    
    <script src="https://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-livereload/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
