<!DOCTYPE HTML>
<html lang="en-US" >
    
    <head>
        
        <meta charset="UTF-8">
        <title>blog | Swift Codeblocks Syntax Highlight</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 1.0.2">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    
    
    <link rel="prev" href="../chapter5/01_documentation.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="../gitbook/style.css">


        
    <div class="book"  data-level="5.2" data-basepath=".." data-revision="1409041136219">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Type to search" class="form-control" />
    </div>
    <ul class="summary">
        
    	
    	
    	

        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../index.html">
                        <i class="fa fa-check"></i>
                        
                         Introduction
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="chapter1/chapter1.html">
            
                
                    <a href="../chapter1/chapter1.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         欢迎使用 Swift
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="1.1" data-path="chapter1/01_swift.html">
            
                
                    <a href="../chapter1/01_swift.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.1.</b>
                        
                         关于 Swift
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.2" data-path="chapter1/02_a_swift_tour.html">
            
                
                    <a href="../chapter1/02_a_swift_tour.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.2.</b>
                        
                         Swift 初见
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.3" data-path="chapter1/03_revision_history.html">
            
                
                    <a href="../chapter1/03_revision_history.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.3.</b>
                        
                         Swift 版本历史记录
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    
        
        <li class="chapter " data-level="2" data-path="chapter2/chapter2.html">
            
                
                    <a href="../chapter2/chapter2.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                         Swift 教程
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="2.1" data-path="chapter2/01_The_Basics.html">
            
                
                    <a href="../chapter2/01_The_Basics.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.1.</b>
                        
                         基础部分
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.2" data-path="chapter2/02_Basic_Operators.html">
            
                
                    <a href="../chapter2/02_Basic_Operators.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.2.</b>
                        
                         基本运算符
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.3" data-path="chapter2/03_Strings_and_Characters.html">
            
                
                    <a href="../chapter2/03_Strings_and_Characters.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.3.</b>
                        
                         字符串和字符
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.4" data-path="chapter2/04_Collection_Types.html">
            
                
                    <a href="../chapter2/04_Collection_Types.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.4.</b>
                        
                         集合类型
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.5" data-path="chapter2/05_Control_Flow.html">
            
                
                    <a href="../chapter2/05_Control_Flow.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.5.</b>
                        
                         控制流
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.6" data-path="chapter2/06_Functions.html">
            
                
                    <a href="../chapter2/06_Functions.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.6.</b>
                        
                         函数
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.7" data-path="chapter2/07_Closures.html">
            
                
                    <a href="../chapter2/07_Closures.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.7.</b>
                        
                         闭包
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.8" data-path="chapter2/08_Enumerations.html">
            
                
                    <a href="../chapter2/08_Enumerations.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.8.</b>
                        
                         枚举
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.9" data-path="chapter2/09_Classes_and_Structures.html">
            
                
                    <a href="../chapter2/09_Classes_and_Structures.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.9.</b>
                        
                         类和结构体
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.10" data-path="chapter2/10_Properties.html">
            
                
                    <a href="../chapter2/10_Properties.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.10.</b>
                        
                         属性
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.11" data-path="chapter2/11_Methods.html">
            
                
                    <a href="../chapter2/11_Methods.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.11.</b>
                        
                         方法
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.12" data-path="chapter2/12_Subscripts.html">
            
                
                    <a href="../chapter2/12_Subscripts.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.12.</b>
                        
                         下标脚本
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.13" data-path="chapter2/13_Inheritance.html">
            
                
                    <a href="../chapter2/13_Inheritance.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.13.</b>
                        
                         继承
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.14" data-path="chapter2/14_Initialization.html">
            
                
                    <a href="../chapter2/14_Initialization.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.14.</b>
                        
                         构造过程
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.15" data-path="chapter2/15_Deinitialization.html">
            
                
                    <a href="../chapter2/15_Deinitialization.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.15.</b>
                        
                         析构过程
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.16" data-path="chapter2/16_Automatic_Reference_Counting.html">
            
                
                    <a href="../chapter2/16_Automatic_Reference_Counting.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.16.</b>
                        
                         自动引用计数
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.17" data-path="chapter2/17_Optional_Chaining.html">
            
                
                    <a href="../chapter2/17_Optional_Chaining.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.17.</b>
                        
                         可选链
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.18" data-path="chapter2/18_Type_Casting.html">
            
                
                    <a href="../chapter2/18_Type_Casting.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.18.</b>
                        
                         类型转换
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.19" data-path="chapter2/19_Nested_Types.html">
            
                
                    <a href="../chapter2/19_Nested_Types.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.19.</b>
                        
                         嵌套类型
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.20" data-path="chapter2/20_Extensions.html">
            
                
                    <a href="../chapter2/20_Extensions.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.20.</b>
                        
                         扩展
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.21" data-path="chapter2/21_Protocols.html">
            
                
                    <a href="../chapter2/21_Protocols.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.21.</b>
                        
                         协议
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.22" data-path="chapter2/22_Generics.html">
            
                
                    <a href="../chapter2/22_Generics.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.22.</b>
                        
                         泛型
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.23" data-path="chapter2/23_Access_Control.html">
            
                
                    <a href="../chapter2/23_Access_Control.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.23.</b>
                        
                         权限控制
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="2.24" data-path="chapter2/24_Advanced_Operators.html">
            
                
                    <a href="../chapter2/24_Advanced_Operators.html">
                        <i class="fa fa-check"></i>
                        
                            <b>2.24.</b>
                        
                         高级操作符
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    
        
        <li class="chapter " data-level="3" data-path="chapter3/chapter3.html">
            
                
                    <a href="../chapter3/chapter3.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                         语言参考
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="3.1" data-path="chapter3/01_About_the_Language_Reference.html">
            
                
                    <a href="../chapter3/01_About_the_Language_Reference.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.1.</b>
                        
                         关于语言参考
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.2" data-path="chapter3/02_Lexical_Structure.html">
            
                
                    <a href="../chapter3/02_Lexical_Structure.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.2.</b>
                        
                         词法结构
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.3" data-path="chapter3/03_Types.html">
            
                
                    <a href="../chapter3/03_Types.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.3.</b>
                        
                         类型
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.4" data-path="chapter3/04_Expressions.html">
            
                
                    <a href="../chapter3/04_Expressions.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.4.</b>
                        
                         表达式
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.5" data-path="chapter3/10_Statements.html">
            
                
                    <a href="../chapter3/10_Statements.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.5.</b>
                        
                         语句
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.6" data-path="chapter3/05_Declarations.html">
            
                
                    <a href="../chapter3/05_Declarations.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.6.</b>
                        
                         声明
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.7" data-path="chapter3/06_Attributes.html">
            
                
                    <a href="../chapter3/06_Attributes.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.7.</b>
                        
                         特性
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.8" data-path="chapter3/07_Patterns.html">
            
                
                    <a href="../chapter3/07_Patterns.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.8.</b>
                        
                         模式
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.9" data-path="chapter3/08_Generic_Parameters_and_Arguments.html">
            
                
                    <a href="../chapter3/08_Generic_Parameters_and_Arguments.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.9.</b>
                        
                         泛型参数
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="3.10" data-path="chapter3/09_Summary_of_the_Grammar.html">
            
                
                    <a href="../chapter3/09_Summary_of_the_Grammar.html">
                        <i class="fa fa-check"></i>
                        
                            <b>3.10.</b>
                        
                         语法总结
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    
        
        <li class="chapter " data-level="4" data-path="chapter4/chapter4.html">
            
                
                    <a href="../chapter4/chapter4.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                         苹果官方Blog官方翻译
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="4.1" data-path="chapter4/01_Access_Control.html">
            
                
                    <a href="../chapter4/01_Access_Control.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.1.</b>
                        
                         权限控制的黑与白
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4.2" data-path="chapter4/02_Type_Custom.html">
            
                
                    <a href="../chapter4/02_Type_Custom.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.2.</b>
                        
                         造个类型不是梦-白话Swift类型创建
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4.3" data-path="chapter4/03_Ballons.html">
            
                
                    <a href="../chapter4/03_Ballons.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.3.</b>
                        
                         WWDC里面的那个“大炮打气球”
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4.4" data-path="chapter4/04_Interacting_with_C_Pointers.html">
            
                
                    <a href="../chapter4/04_Interacting_with_C_Pointers.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.4.</b>
                        
                         与C语言指针的交互
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4.5" data-path="chapter4/05_Value_and_Reference_Types.html">
            
                
                    <a href="../chapter4/05_Value_and_Reference_Types.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.5.</b>
                        
                         引用类型和值类型的恩怨
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="4.6" data-path="chapter4/06_access_control_&amp;_protected.html">
            
                
                    <a href="../chapter4/06_access_control_&amp;_protected.html">
                        <i class="fa fa-check"></i>
                        
                            <b>4.6.</b>
                        
                         访问控制和protected
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    
        
        <li class="chapter " data-level="5" data-path="chapter5/chapter5.html">
            
                
                    <a href="../chapter5/chapter5.html">
                        <i class="fa fa-check"></i>
                        
                            <b>5.</b>
                        
                         苹果官方原文
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="5.1" data-path="chapter5/01_documentation.html">
            
                
                    <a href="../chapter5/01_documentation.html">
                        <i class="fa fa-check"></i>
                        
                            <b>5.1.</b>
                        
                         documentation
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter active" data-level="5.2" data-path="chapter5/02_swift_blog.html">
            
                
                    <a href="../chapter5/02_swift_blog.html">
                        <i class="fa fa-check"></i>
                        
                            <b>5.2.</b>
                        
                         blog
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Published using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">Serif</button>
        <button type="button" data-font="1" class="button">Sans</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">White</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">Sepia</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">Night</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle share dropdown"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">Twitter</button>
                <button type="button" data-sharing="google-plus" class="button">Google</button>
                <button type="button" data-sharing="facebook" class="button">Facebook</button>
                <button type="button" data-sharing="weibo" class="button">Weibo</button>
                <button type="button" data-sharing="instapaper" class="button">Instapaper</button>
            </div>
        </div>
    </div>
    

    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../" >Swift Codeblocks Syntax Highlight</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-gitbook_91">
                    
                        <ul>
<li>Aug 19, 2014</li>
</ul>
<h2 id="access-control-and-protectedhttpsdeveloperapplecomswiftblogid11"><a href="https://developer.apple.com/swift/blog/?id=11" target="_blank">Access Control and protected</a></h2>
<p>The response to support for access control in Swift has been extremely positive. However, some developers have been asking, “Why doesn’t Swift have something like protected?” Many other programming languages have an access control option that restricts certain methods from being accessed from anywhere except subclasses.</p>
<p>When designing access control levels in Swift, we considered two main use cases:</p>
<ul>
<li>keep private details of a class hidden from the rest of the app</li>
<li>keep internal details of a framework hidden from the client app</li>
</ul>
<p>These correspond to private and internal levels of access, respectively.</p>
<p>In contrast, protected conflates access with inheritance, adding an entirely new control axis to reason about. It doesn’t actually offer any real protection, since a subclass can always expose “protected” API through a new public method or property. It doesn’t offer additional optimization opportunities either, since new overrides can come from anywhere. And it’s unnecessarily restrictive — it allows subclasses, but not any of the subclass’s helpers, to access something.</p>
<p>As some developers have pointed out, Apple frameworks do occasionally separate parts of API intended for use by subclasses. Wouldn’t protected be helpful here? Upon inspection, these methods generally fall into one of two groups. First, methods that aren’t really useful outside the subclass, so protection isn’t critical (and recall the helper case above). Second, methods that are designed to be overridden but not called. An example is drawRect(_:), which is certainly used within the UIKit codebase but is not to be called outside UIKit.</p>
<p>It’s also not clear how protected should interact with extensions. Does an extension to a class have access to that class’s protected members? Does an extension to a subclass have access to the superclass’s protected members? Does it make a difference if the extension is declared in the same module as the class?</p>
<p>There was one other influence that led us to the current design: existing practices of Objective-C developers both inside and outside of Apple. Objective-C methods and properties are generally declared in a public header (.h) file, but can also be added in class extensions within the implementation (.m) file. When parts of a public class are intended for use elsewhere within the framework but not outside, developers create a second header file with the class’s “internal” bits. These three levels of access correspond to public, private, and internal in Swift.</p>
<p>Swift provides access control along a single, easy-to-understand axis, unrelated to inheritance. We believe this model is simpler, and provides access control the way it is most often needed: to isolate implementation details to within a class or within a framework. It may be different from what you’ve used before, but we encourage you to try it out.</p>
<ul>
<li>Aug 15, 2014</li>
</ul>
<h2 id="value-and-reference-typeshttpsdeveloperapplecomswiftblogid10"><a href="https://developer.apple.com/swift/blog/?id=10" target="_blank">Value and Reference Types</a></h2>
<p>Types in Swift fall into one of two categories: first, “value types”, where each instance keeps a unique copy of its data, usually defined as a struct, enum, or tuple. The second, “reference types”, where instances share a single copy of the data, and the type is usually defined as a class. In this post we explore the merits of value and reference types, and how to choose between them. </p>
<h3 id="whats-the-difference">What’s the Difference?</h3>
<p>The most basic distinguishing feature of a <em>value type</em> is that copying — the effect of assignment, initialization, and argument passing — creates an <em>independent instance</em> with its own unique copy of its data:</p>
<pre><code class="lang-swift">  <span class="hljs-comment">// Value type example</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S</span> </span>{ <span class="hljs-keyword">var</span> data: <span class="hljs-type">Int</span> = -<span class="hljs-number">1</span> }
  <span class="hljs-keyword">var</span> a = <span class="hljs-type">S</span>()
  <span class="hljs-keyword">var</span> b = a       <span class="hljs-comment">// a is copied to b</span>
  a.data = <span class="hljs-number">42</span>       <span class="hljs-comment">// Changes a, not b</span>
  <span class="hljs-built_in">println</span>(<span class="hljs-string">"<span class="hljs-subst">\(a.data)</span>, <span class="hljs-subst">\(b.data)</span>"</span>) <span class="hljs-comment">// prints "42, -1"</span>
</code></pre>
<p>Copying a reference, on the other hand, implicitly creates a shared instance. After a copy, two variables then refer to a single instance of the data, so modifying data in the second variable also affects the original, e.g.:</p>
<pre><code class="lang-swift">  <span class="hljs-comment">// Reference type example</span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>{ <span class="hljs-keyword">var</span> data: <span class="hljs-type">Int</span> = -<span class="hljs-number">1</span> }
  <span class="hljs-keyword">var</span> x = <span class="hljs-type">C</span>()
  <span class="hljs-keyword">var</span> y = x       <span class="hljs-comment">// x is copied to y</span>
  x.data = <span class="hljs-number">42</span>       <span class="hljs-comment">// changes the instance referred to by x (and y)</span>
  <span class="hljs-built_in">println</span>(<span class="hljs-string">"<span class="hljs-subst">\(x.data)</span>, <span class="hljs-subst">\(y.data)</span>"</span>) <span class="hljs-comment">// prints "42, 42"</span>
</code></pre>
<h3 id="the-role-of-mutation-in-safety">The Role of Mutation in Safety</h3>
<p>One of the primary reasons to choose value types over reference types is the ability to more easily reason about your code. If you always get a unique, copied instance, you can trust that no other part of your app is changing the data under the covers. This is especially helpful in multi-threaded environments where a different thread could alter your data out from under you. This can create nasty bugs that are extremely hard to debug.</p>
<p>Because the difference is defined in terms of what happens when you change data, there’s one case where value and reference types overlap: when instances have no writable data. In the absence of mutation, values and references act exactly the same way.</p>
<p>You may be thinking that it could be valuable, then, to have a case where a class is completely immutable. This would make it easier to use Cocoa NSObject objects, while maintaining the benefits of value semantics. Today, you can write an immutable class in Swift by using only immutable stored properties and avoiding exposing any APIs that can modify state. In fact, many common Cocoa classes, such as NSURL, are designed as immutable classes. However, Swift does not currently provide any language mechanism to enforce class immutability (e.g. on subclasses) the way it enforces immutability for struct and enum.</p>
<h3 id="how-to-choose">How to Choose?</h3>
<p>So if you want to build a new type, how do you decide which kind to make? When you’re working with Cocoa, many APIs expect subclasses of NSObject, so you have to use a class. For the other cases, here are some guidelines:</p>
<p>Use a value type when:</p>
<ul>
<li>Comparing instance data with == makes sense</li>
<li>You want copies to have independent state</li>
<li>The data will be used in code across multiple threads</li>
</ul>
<p>Use a reference type (e.g. use a class) when:</p>
<ul>
<li>Comparing instance identity with === makes sense</li>
<li>You want to create shared, mutable state</li>
</ul>
<p>In Swift, Array, String, and Dictionary are all value types. They behave much like a simple int value in C, acting as a unique instance of that data. You don’t need to do anything special — such as making an explicit copy — to prevent other code from modifying that data behind your back. Importantly, you can safely pass copies of values across threads without synchronization. In the spirit of improving safety, this model will help you write more predictable code in Swift.</p>
<ul>
<li>Aug 8, 2014</li>
</ul>
<h2 id="balloonshttpsdeveloperapplecomswiftblogid9"><a href="https://developer.apple.com/swift/blog/?id=9" target="_blank">Balloons</a></h2>
<p>Many people have asked about the Balloons playground we demonstrated when introducing Swift at WWDC. Balloons shows that writing code can be interactive and fun, while presenting several great features of playgrounds. Now you can learn how the special effects were done with this tutorial version of ‘Balloons.playground’, which includes documentation and suggestions for experimentation.</p>
<p>This playground uses new features of SpriteKit and requires the latest beta versions of Xcode 6 and OS X Yosemite.</p>
<ul>
<li><p><a href="https://developer.apple.com/swift/blog/downloads/Balloons.zip" target="_blank">Balloons.playground</a></p>
</li>
<li><p>Aug 5, 2014</p>
</li>
</ul>
<h2 id="booleanhttpsdeveloperapplecomswiftblogid8"><a href="https://developer.apple.com/swift/blog/?id=8" target="_blank">Boolean</a></h2>
<p>The boolean Bool type in Swift underlies a lot of primitive functionality, making it an interesting demonstration of how to build a simple type. This post walks through the creation of a new MyBool type designed and implemented to be very similar to the Bool type built into Swift. We hope this walk through the design of a simple Swift type will help you better understand how the language works.</p>
<p>Let’s start with the basic definition. The MyBool type models two different cases, perfect for an enum:</p>
<pre><code class="lang-swift">  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">MyBool</span> </span>{
    <span class="hljs-keyword">case</span> myTrue, myFalse
  }
</code></pre>
<p>To reduce confusion in this post, we’ve named the cases myTrue and myFalse. We want MyBool() to produce a false value, and can do so by providing an init method:</p>
<pre><code class="lang-swift">  <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">MyBool</span> </span>{
    <span class="hljs-keyword">init</span>() { <span class="hljs-keyword">self</span> = .myFalse }
  }
</code></pre>
<p>Swift enum declarations implicitly scope their enumerators within their body, allowing us to refer to MyBool.myFalse and even .myFalse when a contextual type is available. However, we want our type to work with the primitive true and false literal keywords. To make this work, we can make MyBool conform to the BooleanLiteralConvertible protocol like this:</p>
<pre><code class="lang-swift">  <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">MyBool</span> : <span class="hljs-title">BooleanLiteralConvertible</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-func"><span class="hljs-keyword">func</span></span> convertFromBooleanLiteral(value: <span class="hljs-type">Bool</span>) -&gt; <span class="hljs-type">MyBool</span> {
    <span class="hljs-keyword">return</span> value ? myTrue : myFalse
    }
  }

  <span class="hljs-comment">// We can now assign 'true' and 'false' to MyBool.</span>
  <span class="hljs-keyword">var</span> a : <span class="hljs-type">MyBool</span> = <span class="hljs-built_in">true</span>
</code></pre>
<p>With this set up, we have our basic type, but we still can’t do much with it. Booleans need to be testable within an if condition. Swift models this with the BooleanType protocol, which allows any type to be used as a logical condition:</p>
<pre><code class="lang-swift">  <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">MyBool</span> : <span class="hljs-title">BooleanType</span> </span>{
    <span class="hljs-keyword">var</span> boolValue: <span class="hljs-type">Bool</span> {
      <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> {
      <span class="hljs-keyword">case</span> .myTrue: <span class="hljs-keyword">return</span> <span class="hljs-built_in">true</span>
      <span class="hljs-keyword">case</span> .myFalse: <span class="hljs-keyword">return</span> <span class="hljs-built_in">false</span>
      }
    }
  }

  <span class="hljs-comment">// Can now test MyBool in 'if' and 'while' statement conditions.</span>
  <span class="hljs-keyword">if</span> a {}
</code></pre>
<p>We also want anything that conforms to BooleanType to be castable to MyBool, so we add:</p>
<pre><code class="lang-swift">  <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">MyBool</span> </span>{
    <span class="hljs-comment">// MyBool can be constructed from BooleanType</span>
      <span class="hljs-keyword">init</span>(<span class="hljs-number">_</span> v : <span class="hljs-type">BooleanType</span>) {
        <span class="hljs-keyword">if</span> v.boolValue {
          <span class="hljs-keyword">self</span> = .myTrue
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">self</span> = .myFalse
        }
      }
  }

  <span class="hljs-comment">// Can now convert from other boolean-like types.</span>
  <span class="hljs-keyword">var</span> basicBool : <span class="hljs-type">Bool</span> = <span class="hljs-built_in">true</span>
  a = <span class="hljs-type">MyBool</span>(basicBool)
</code></pre>
<p>Note that the use of _ in the initializer argument list disables the keyword argument, which allows the MyBool(x) syntax to be used instead of requiring MyBool(v: x).</p>
<p>Now that we have basic functionality, let’s define some operators to work with it, starting with the == operator. Simple enums that have no associated data (like MyBool) are automatically made Equatable by the compiler, so no additional code is required. However, you can make arbitrary types equatable by conforming to the Equatable protocol and implementing the == operator. If MyBool weren’t already Equatable, this would look like this:</p>
<pre><code class="lang-swift">  <span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">MyBool</span> : <span class="hljs-title">Equatable</span> </span>{
  }

  <span class="hljs-func"><span class="hljs-keyword">func</span></span> ==(lhs: <span class="hljs-type">MyBool</span>, rhs: <span class="hljs-type">MyBool</span>) -&gt; <span class="hljs-type">Bool</span> {
    <span class="hljs-keyword">switch</span> (lhs, rhs) {
      <span class="hljs-keyword">case</span> (.myTrue,.myTrue), (.myFalse,.myFalse):
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">true</span>
      <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">false</span>
    }
  }

  <span class="hljs-comment">// Can now compare with == and !=</span>
  <span class="hljs-keyword">if</span> a == a {}
  <span class="hljs-keyword">if</span> a != a {}
</code></pre>
<p>Here we’re using some simple pattern matching in the switch statement to handle this. Since MyBool is now Equatable, we get a free implementation of the != operator. Lets add binary operations:</p>
<pre><code class="lang-swift">  <span class="hljs-func"><span class="hljs-keyword">func</span></span> &amp;(lhs: <span class="hljs-type">MyBool</span>, rhs: <span class="hljs-type">MyBool</span>) -&gt; <span class="hljs-type">MyBool</span> {
    <span class="hljs-keyword">if</span> lhs {
      <span class="hljs-keyword">return</span> rhs
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">false</span>
  }

  <span class="hljs-func"><span class="hljs-keyword">func</span></span> |(lhs: <span class="hljs-type">MyBool</span>, rhs: <span class="hljs-type">MyBool</span>) -&gt; <span class="hljs-type">MyBool</span> {
    <span class="hljs-keyword">if</span> lhs {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">true</span>
    }
    <span class="hljs-keyword">return</span> rhs
  }

  <span class="hljs-func"><span class="hljs-keyword">func</span></span> ^(lhs: <span class="hljs-type">MyBool</span>, rhs: <span class="hljs-type">MyBool</span>) -&gt; <span class="hljs-type">MyBool</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-type">MyBool</span>(lhs != rhs)
  }
</code></pre>
<p>With the basic operators in place, we can implement a variety of helpful unary and compound assignment operators as well, for example:</p>
<pre><code class="lang-swift">  <span class="hljs-keyword">prefix</span> <span class="hljs-func"><span class="hljs-keyword">func</span></span> !(a: <span class="hljs-type">MyBool</span>) -&gt; <span class="hljs-type">MyBool</span> {
  <span class="hljs-keyword">return</span> a ^ <span class="hljs-built_in">true</span>
  }

  <span class="hljs-comment">// Compound assignment (with bitwise and)</span>
  <span class="hljs-func"><span class="hljs-keyword">func</span></span> &amp;=(<span class="hljs-keyword">inout</span> lhs: <span class="hljs-type">MyBool</span>, rhs: <span class="hljs-type">MyBool</span>) {
    lhs = lhs &amp; rhs
  }
</code></pre>
<p>The &amp;= operator takes the left operand as inout because it reads and writes to it, and the effect must be visible to the user of the operator. Swift gives you complete control over mutability of operations on value types like enum and struct.</p>
<p>With this, the simple MyBool type has all of the basic operations and operators. Hopefully this post gives you a few tips that you can apply to your own code when defining higher-level types.</p>
<ul>
<li>Aug 1, 2014</li>
</ul>
<h2 id="files-and-initializationhttpsdeveloperapplecomswiftblogid7"><a href="https://developer.apple.com/swift/blog/?id=7" target="_blank">Files and Initialization</a></h2>
<p>By now, most of you have written a small Swift app or experimented in the playground. You may even have experienced an error after you copied code from a playground into another file and wondered, “What is actually going on? What is the difference between a playground file, and other Swift source files?” This post will explain how Swift deals with the files in your project, and how global data is initialized.</p>
<h3 id="files-in-an-app">Files in an App</h3>
<p>A Swift app is composed of any number of files, each with the functions, classes, and other declarations that make up the app. Most Swift files in your app are <strong>order-independent</strong>, meaning you can use a type before it is defined, and can even import modules at the bottom of the file (although that is not recommended Swift style.)</p>
<p>However, top-level code is not allowed in most of your Swift source files. For clarity, any executable statement not written within a function body, within a class, or otherwise encapsulated is considered top-level. We have this rule because if top-level code were allowed in all your files, it would be hard to determine where to start the program.</p>
<h3 id="playgrounds-repl-and-top-level-code">Playgrounds, REPL, and Top-Level Code</h3>
<p>You may be wondering why the code below works perfectly in a playground. This example isn’t encapsulated in anything, so it must be top-level code:</p>
<pre><code class="lang-swift">  <span class="hljs-built_in">println</span>(<span class="hljs-string">"Hello world"</span>)
</code></pre>
<p>The above single-line program works — with no additional code at all — because playground files do support the execution of top-level code. Code within a playground file is <strong>order-dependent</strong>, run in top-down lexical order. For example, you can’t use a type before you define it. Of course, Swift playground files can also define functions, classes, and any other legal Swift code, but they don’t need to. This makes it easy to learn the Swift language or try a new API without writing a lot of code to get started.</p>
<p>In addition to playgrounds, top-level code can also be run in the REPL (Read-Eval-Print-Loop) or when launching Swift files as scripts. To use Swift for scripting, you can use shebang-style launching by starting your Swift file with “#!/usr/bin/xcrun swift” or type “xcrun swift myFile.swift” within Terminal.</p>
<h3 id="application-entry-points-and-mainswift">Application Entry Points and “main.swift”</h3>
<p>You’ll notice that earlier we said top-level code isn’t allowed in <em>most</em> of your app’s source files. The exception is a special file named “main.swift”, which behaves much like a playground file, but is built with your app’s source code. The “main.swift” file can contain top-level code, and the order-dependent rules apply as well. In effect, the first line of code to run in “main.swift” is implicitly defined as the main entrypoint for the program. This allows the minimal Swift program to be a single line — as long as that line is in “main.swift”.</p>
<p>In Xcode, Mac templates default to including a “main.swift” file, but for iOS apps the default for new iOS project templates is to add @UIApplicationMain to a regular Swift file. This causes the compiler to synthesize a main entry point for your iOS app, and eliminates the need for a “main.swift” file.</p>
<p>Alternatively, you can link in an implementation of main written in Objective-C, common when incrementally migrating projects from Objective-C to Swift.</p>
<h3 id="global-variables">Global Variables</h3>
<p>Given how Swift determines where to start executing an app, how should global variables work? In the following line of code, when should the initializer run?</p>
<pre><code class="lang-swift">  <span class="hljs-keyword">var</span> someGlobal = foo()
</code></pre>
<p>In a single-file program, code is executed top-down, similar to the behavior of variables within a function. Pretty simple. The answer for complex apps is less obvious, and we considered three different options:</p>
<ul>
<li>Restrict initializers of global variables to be simple constant expressions, as C does.</li>
<li>Allow any initializer, run as a static constructor at app load time, as C++ does.</li>
<li>Initialize lazily, run the initializer for a global the first time it is referenced, similar to Java.</li>
</ul>
<p>The first approach was ruled out because Swift doesn’t need constant expressions like C does. In Swift, constants are generally implemented as (inlined) function calls. And there are good reasons to use complex initializers, e.g. to set up singletons or allocate a dictionary.</p>
<p>The second approach was ruled out because it is bad for the performance of large systems, as all of the initializers in all the files must run before the application starts up. This is also unpredictable, as the order of initialization in different files is unspecified.</p>
<p>Swift uses the third approach, which is the best of all worlds: it allows custom initializers, startup time in Swift scales cleanly with no global initializers to slow it down, and the order of execution is completely predictable.</p>
<p>The lazy initializer for a global variable (also for static members of structs and enums) is run the first time that global is accessed, and is launched as dispatch_once to make sure that the initialization is atomic. This enables a cool way to use dispatch_once in your code: just declare a global variable with an initializer and mark it private.</p>
<h3 id="summary">Summary</h3>
<p>Swift is designed to make it easy to experiment in a playground or to quickly build a script. A complete program can be a single line of code. Of course, Swift was also designed to scale to the most complex apps you can dream up. With “main.swift” you can take complete control over initialization or you can let @UIApplicationMain do the startup work for you on iOS.</p>
<ul>
<li>Jul 28, 2014</li>
</ul>
<h2 id="interacting-with-c-pointershttpsdeveloperapplecomswiftblogid6"><a href="https://developer.apple.com/swift/blog/?id=6" target="_blank">Interacting with C Pointers</a></h2>
<p>Objective-C and C APIs often require the use of pointers. Data types in Swift are designed to feel natural when working with pointer-based Cocoa APIs, and Swift automatically handles several of the most common use cases for pointers as arguments. In this post we’ll look at how pointer parameters in C can be used with the variables, arrays, and strings in Swift.</p>
<h3 id="pointers-as-inout-parameters">Pointers as In/Out Parameters</h3>
<p>C and Objective-C don’t support multiple return values, so Cocoa APIs frequently use pointers as a way of passing additional data in and out of functions. Swift allows pointer parameters to be treated like inout parameters, so you can pass a reference to a var as a pointer argument by using the same &amp; syntax. For instance, UIColor’s getRed(_:green:blue:alpha:) method takes four CGFloat* pointers to receive the components of the color. We can use &amp; to collect these components into local variables:</p>
<pre><code class="lang-swift">  <span class="hljs-keyword">var</span> r: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>, g: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>, b: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>, a: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
  color.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)
</code></pre>
<p>Another common case is the Cocoa NSError idiom. Many methods take an NSError** parameter to save an error in case of failure. For instance, we can list the contents of a directory using NSFileManager’s contentsOfDirectoryAtPath(_:error:) method, saving the potential error directly to an NSError? variable:</p>
<pre><code class="lang-swift">  <span class="hljs-keyword">var</span> maybeError: <span class="hljs-type">NSError</span>?
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> contents = <span class="hljs-type">NSFileManager</span>.defaultManager()
    .contentsOfDirectoryAtPath(<span class="hljs-string">"/usr/bin"</span>, error: &amp;maybeError) {
      <span class="hljs-comment">// Work with the directory contents</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error = maybeError {
    <span class="hljs-comment">// Handle the error</span>
  }
</code></pre>
<p>For safety, Swift requires the variables to be initialized before being passed with &amp;. This is because it cannot know whether the method being called tries to read from a pointer before writing to it.</p>
<h3 id="pointers-as-array-parameters">Pointers as Array Parameters</h3>
<p>Pointers are deeply intertwined with arrays in C, and Swift facilitates working with array-based C APIs by allowing Array to be used as a pointer argument. An immutable array value can be passed directly as a const pointer, and a mutable array can be passed as a non-const pointer argument using the &amp; operator, just like an inout parameter. For instance, we can add two arrays a and b using the vDSP_vadd function from the Accelerate framework, writing the result to a third result array:</p>
<pre><code class="lang-swift">  <span class="hljs-keyword">import</span> <span class="hljs-type">Accelerate</span>

  <span class="hljs-keyword">let</span> a: [<span class="hljs-type">Float</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
  <span class="hljs-keyword">let</span> b: [<span class="hljs-type">Float</span>] = [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.125</span>, <span class="hljs-number">0.0625</span>]
  <span class="hljs-keyword">var</span> result: [<span class="hljs-type">Float</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]

  vDSP_vadd(a, <span class="hljs-number">1</span>, b, <span class="hljs-number">1</span>, &amp;result, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)

  <span class="hljs-comment">// result now contains [1.5, 2.25, 3.125, 4.0625]</span>
</code></pre>
<h3 id="pointers-as-string-parameters">Pointers as String Parameters</h3>
<p>C uses const char<em> pointers as the primary way to pass around strings. A Swift String can be used as a const char</em> pointer, which will pass the function a pointer to a null-terminated, UTF–8-encoded representation of the string. For instance, we can pass strings directly to standard C and POSIX library functions:</p>
<pre><code class="lang-swift">  puts(<span class="hljs-string">"Hello from libc"</span>)
  <span class="hljs-keyword">let</span> fd = open(<span class="hljs-string">"/tmp/scratch.txt"</span>, <span class="hljs-type">O_WRONLY</span>|<span class="hljs-type">O_CREAT</span>, <span class="hljs-number">0o666</span>)

  <span class="hljs-keyword">if</span> fd &lt; <span class="hljs-number">0</span> {
    perror(<span class="hljs-string">"could not open /tmp/scratch.txt"</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">let</span> text = <span class="hljs-string">"Hello World"</span>
    write(fd, text, strlen(text))
    close(fd)
  }
</code></pre>
<h3 id="safety-with-pointer-argument-conversions">Safety with Pointer Argument Conversions</h3>
<p>Swift works hard to make interaction with C pointers convenient, because of their pervasiveness within Cocoa, while providing some level of safety. However, interaction with C pointers is inherently unsafe compared to your other Swift code, so care must be taken. In particular:</p>
<ul>
<li>These conversions cannot safely be used if the callee saves the pointer value for use after it returns. The pointer that results from these conversions is only guaranteed to be valid for the duration of a call. Even if you pass the same variable, array, or string as multiple pointer arguments, you could receive a different pointer each time. An exception to this is global or static stored variables. You can safely use the address of a global variable as a persistent unique pointer value, e.g.: as a KVO context parameter.</li>
<li>Bounds checking is not enforced when a pointer to an Array or String is passed. A C-based API can’t grow the array or string, so you must ensure that the array or string is of the correct size before passing it over to the C-based API.</li>
</ul>
<p>If you need to work with pointer-based APIs that don’t follow these guidelines, or you need to override Cocoa methods that accept pointer parameters, then you can work directly with raw memory in Swift using unsafe pointers. We’ll look at a more advanced case in a future post.</p>
<ul>
<li>Jul 23, 2014</li>
</ul>
<h2 id="access-controlhttpsdeveloperapplecomswiftblogid5"><a href="https://developer.apple.com/swift/blog/?id=5" target="_blank">Access Control</a></h2>
<p>In Xcode 6 beta 4, Swift adds support for access control. This gives you complete control over what part of the code is accessible within a single file, available across your project, or made public as API for anyone that imports your framework. The three access levels included in this release are:</p>
<ul>
<li>private entities are available only from within the source file where they are defined.</li>
<li>internal entities are available to the entire module that includes the definition (e.g. an app or framework target).</li>
<li>public entities are intended for use as API, and can be accessed by any file that imports the module, e.g. as a framework used in several of your projects.</li>
</ul>
<p>By default, all entities have internal access. This allows application developers to largely ignore access control, and most Swift code already written will continue to work without change. Your framework code does need to be updated to define public API, giving you total control of the exposed interface your framework provides.</p>
<p>The private access level is the most restrictive, and makes it easy to hide implementation details from other source files. By properly structuring your code, you can safely use features like extensions and top-level functions without exposing that code to the rest of your project.</p>
<p>Developers building frameworks to be used across their projects need to mark their API as public. While distribution and use of 3rd-party binary frameworks is not recommended (as mentioned in a previous blog post), Swift supports construction and distribution of frameworks in source form.</p>
<p>In addition to allowing access specification for an entire declaration, Swift allows the get of a property to be more accessible than its set. Here is an example class that is part of a framework:</p>
<pre><code class="lang-swift">  public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListItem</span> </span>{

    <span class="hljs-comment">// Public properties.</span>
    public <span class="hljs-keyword">var</span> text: <span class="hljs-type">String</span>
    public <span class="hljs-keyword">var</span> isComplete: <span class="hljs-type">Bool</span>

    <span class="hljs-comment">// Readable throughout the module, but only writeable from within this file.</span>
    private(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> <span class="hljs-type">UUID</span>: <span class="hljs-type">NSUUID</span>

    public <span class="hljs-keyword">init</span>(text: <span class="hljs-type">String</span>, completed: <span class="hljs-type">Bool</span>, <span class="hljs-type">UUID</span>: <span class="hljs-type">NSUUID</span>) {
      <span class="hljs-keyword">self</span>.text = text
      <span class="hljs-keyword">self</span>.isComplete = completed
      <span class="hljs-keyword">self</span>.<span class="hljs-type">UUID</span> = <span class="hljs-type">UUID</span>
    }

    <span class="hljs-comment">// Usable within the framework target, but not by other targets.</span>
    <span class="hljs-func"><span class="hljs-keyword">func</span></span> refreshIdentity() {
      <span class="hljs-keyword">self</span>.<span class="hljs-type">UUID</span> = <span class="hljs-type">NSUUID</span>()
    }

    public <span class="hljs-keyword">override</span> <span class="hljs-func"><span class="hljs-keyword">func</span></span> isEqual(object: <span class="hljs-type">AnyObject</span>?) -&gt; <span class="hljs-type">Bool</span> {
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> item = object <span class="hljs-keyword">as</span>? <span class="hljs-type">ListItem</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.<span class="hljs-type">UUID</span> == item.<span class="hljs-type">UUID</span>
      }
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">false</span>
    }
  }
</code></pre>
<p>When mixing Objective-C and Swift, because the generated header for a framework is part of the framework’s public Objective-C interface, only declarations marked public appear in the generated header for a Swift framework. For applications, the generated header contains both public and internal declarations.</p>
<p>For more information, <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/" target="_blank">The Swift Programming Language</a> and <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/" target="_blank">Using Swift with Cocoa and Objective-C</a> books have been updated to cover access control. <a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_6_beta_4_o2p8fz/xcode_6_beta_4_release_notes.pdf" target="_blank">Read the complete Xcode 6 beta 4 release notes here</a>.</p>
<ul>
<li>Jul 18, 2014</li>
</ul>
<h2 id="building-assert-in-swift-part-1-lazy-evaluationhttpsdeveloperapplecomswiftblogid4"><a href="https://developer.apple.com/swift/blog/?id=4" target="_blank">Building assert() in Swift, Part 1: Lazy Evaluation</a></h2>
<p>UPDATE: This post has been updated to reflect a change in Xcode 6 beta 5 that renamed @auto_closure to @autoclosure, and LogicValue to BooleanType.</p>
<p>When designing Swift we made a key decision to do away with the C preprocessor, eliminating bugs and making code much easier to understand. This is a big win for developers, but it also means Swift needs to implement some old features in new ways. Most of these features are obvious (importing modules, conditional compilation), but perhaps the most interesting one is how Swift supports macros like assert().</p>
<p>When building for release in C, the assert() macro has no runtime performance impact because it doesn’t evaluate any arguments. One popular implementation in C looks like this:</p>
<pre><code class="lang-swift">  #ifdef <span class="hljs-type">NDEBUG</span>
  #define <span class="hljs-built_in">assert</span>(e)  ((void)<span class="hljs-number">0</span>)
  #<span class="hljs-keyword">else</span>
  #define <span class="hljs-built_in">assert</span>(e)  \
    ((void) ((e) ? ((void)<span class="hljs-number">0</span>) : __assert (#e, <span class="hljs-keyword">__FILE__</span>, <span class="hljs-keyword">__LINE__</span>)))
  #define __assert(e, file, line) \
    ((void)printf (<span class="hljs-string">"%s:%u: failed assertion `%s'\n"</span>, file, line, e), abort())
  #endif
</code></pre>
<p>Swift’s assert analog provides almost all of the functionality of C’s assert, without using the preprocessor, and in a much cleaner way. Let’s dive in and learn about some interesting features of Swift.</p>
<h3 id="lazy-evaluation-of-arguments">Lazy Evaluation of Arguments</h3>
<p>When implementing assert() in Swift, the first challenge we encounter is that there is no obvious way for a function to accept an expression without evaluating it. For example, say we tried to use:</p>
<pre><code class="lang-swift">  <span class="hljs-func"><span class="hljs-keyword">func</span></span> <span class="hljs-built_in">assert</span>(x : <span class="hljs-type">Bool</span>) {
    #<span class="hljs-keyword">if</span> !<span class="hljs-type">NDEBUG</span>

    <span class="hljs-comment">/*noop*/</span>
    #endif
  }
</code></pre>
<p>Even when assertions are disabled, the application would take the performance hit of evaluating the expression:</p>
<pre><code class="lang-swift">  <span class="hljs-built_in">assert</span>(someExpensiveComputation() != <span class="hljs-number">42</span>)
</code></pre>
<p>One way we could fix this is by changing the definition of assert to take a closure:</p>
<pre><code class="lang-swift">  <span class="hljs-func"><span class="hljs-keyword">func</span></span> <span class="hljs-built_in">assert</span>(predicate : () -&gt; <span class="hljs-type">Bool</span>) {
    #<span class="hljs-keyword">if</span> !<span class="hljs-type">NDEBUG</span>
    <span class="hljs-keyword">if</span> !predicate() {
      abort()
    }
    #endif
  }
</code></pre>
<p>This evaluates the expression only when assertions are enabled, like we want, but it leaves us with an unfortunate calling syntax:</p>
<pre><code class="lang-swift">  <span class="hljs-built_in">assert</span>({ someExpensiveComputation() != <span class="hljs-number">42</span> })
</code></pre>
<p>We can fix this by using the Swift @autoclosure attribute. The auto-closure attribute can be used on an argument to a function to indicate that an unadorned expression should be implicitly wrapped in a closure to the function. The example then looks like this:</p>
<pre><code class="lang-swift">  <span class="hljs-func"><span class="hljs-keyword">func</span></span> <span class="hljs-built_in">assert</span>(predicate : @autoclosure () -&gt; <span class="hljs-type">Bool</span>) {
    #<span class="hljs-keyword">if</span> !<span class="hljs-type">NDEBUG</span>
    <span class="hljs-keyword">if</span> !predicate() {
      abort()
    }
    #endif
  }

<span class="hljs-type">This</span> allows you to call it naturally, <span class="hljs-keyword">as</span> <span class="hljs-keyword">in</span>:

```<span class="hljs-built_in">swift</span>   
  <span class="hljs-built_in">assert</span>(someExpensiveComputation() != <span class="hljs-number">42</span>)
</code></pre>
<p>Auto-closures are a powerful feature because you can conditionally evaluate an expression, evaluate it many times, and use the bound expression in any way a closure can be used. Auto-closures are used in other places in Swift as well. For example, the implementation of short-circuiting logical operators looks like this:</p>
<pre><code class="lang-swift">  <span class="hljs-func"><span class="hljs-keyword">func</span></span> &amp;&amp;(lhs: <span class="hljs-type">BooleanType</span>, rhs: @autoclosure () -&gt; <span class="hljs-type">BooleanType</span>) -&gt; <span class="hljs-type">Bool</span> {
    <span class="hljs-keyword">return</span> lhs.boolValue ? rhs().boolValue : <span class="hljs-built_in">false</span>
  }
</code></pre>
<p>By taking the right side of the expression as an auto-closure, Swift provides proper lazy evaluation of that subexpression.</p>
<h3 id="auto-closures">Auto-Closures</h3>
<p>As with macros in C, auto-closures are a very powerful feature that must be used carefully because there is no indication on the caller side that argument evaluation is affected. Auto-closures are intentionally limited to only take an empty argument list, and you shouldn’t use them in cases that feel like control flow. Use them when they provide useful semantics that people would expect (perhaps for a “futures” API) but don’t use them just to optimize out the braces on closures.</p>
<p>This covers one special aspect of the implementation of assert in Swift, but there is more to come.</p>
<ul>
<li>Jul 15, 2014</li>
</ul>
<h2 id="swift-language-changes-in-xcode-6-beta-3httpsdeveloperapplecomswiftblogid3"><a href="https://developer.apple.com/swift/blog/?id=3" target="_blank">Swift Language Changes in Xcode 6 beta 3</a></h2>
<p>The Swift programming language continues to advance with each new Xcode 6 beta, including new features, syntax enhancements, and behavioral refinements. Xcode 6 beta 3 incorporates some important changes, a few of which we’d like to highlight:</p>
<ul>
<li>Array has been completely redesigned to have full value semantics to match the behavior of Dictionary and String. Now a let array is completely immutable, and a var array is completely mutable.</li>
<li>Syntax “sugar” for Array and Dictionary has changed. Arrays are declared using [Int] as short hand for Array<Int>, instead of Int[]. Similarly, Dictionary uses [Key: Value] for Dictionary<Key, Value>.</li>
<li>The half-open range operator has been changed from .. to ..&lt; to make it more clear alongside the ... operator for closed ranges.</li>
</ul>
<p>Xcode 6 beta is free to Registered Apple Developers and can be downloaded on the <a href="https://developer.apple.com/xcode/downloads/" target="_blank">Xcode downloads page</a>. Read all about these and other changes in the complete <a href="https://developer.apple.com/library/prerelease/ios/releasenotes/DeveloperTools/RN-Xcode/" target="_blank">release notes for Xcode 6 beta 3.</a></p>
<ul>
<li>Jul 11, 2014</li>
</ul>
<h2 id="compatibilityhttpsdeveloperapplecomswiftblogid2"><a href="https://developer.apple.com/swift/blog/?id=2" target="_blank">Compatibility</a></h2>
<p>One of the most common questions we heard at WWDC was, “What is the compatibility story for Swift?”. This seems like a great first topic.</p>
<h3 id="app-compatibility">App Compatibility</h3>
<p>Simply put, if you write a Swift app today and submit it to the App Store this Fall when iOS 8 and OS X Yosemite are released, you can trust that your app will work well into the future. In fact, you can target back to OS X Mavericks or iOS 7 with that same app. This is possible because Xcode embeds a small Swift runtime library within your app’s bundle. Because the library is embedded, your app uses a consistent version of Swift that runs on past, present, and future OS releases.</p>
<h3 id="binary-compatibility-and-frameworks">Binary Compatibility and Frameworks</h3>
<p>While your app’s runtime compatibility is ensured, the Swift language itself will continue to evolve, and the binary interface will also change. To be safe, all components of your app should be built with the same version of Xcode and the Swift compiler to ensure that they work together.</p>
<p>This means that frameworks need to be managed carefully. For instance, if your project uses frameworks to share code with an embedded extension, you will want to build the frameworks, app, and extensions together. It would be dangerous to rely upon binary frameworks that use Swift — especially from third parties. As Swift changes, those frameworks will be incompatible with the rest of your app. When the binary interface stabilizes in a year or two, the Swift runtime will become part of the host OS and this limitation will no longer exist.</p>
<h3 id="source-compatibility">Source Compatibility</h3>
<p>Swift is ready to use today, in brand new apps or alongside your proven Objective-C code. We have big plans for the Swift language, including improvements to syntax, and powerful new features. And as Swift evolves, we will provide tools in Xcode to help you migrate your source code forward.</p>
<p>We can’t wait to see what you build!</p>
<ul>
<li>Jul 11, 2014</li>
</ul>
<h2 id="welcome-to-swift-bloghttpsdeveloperapplecomswiftblogid1"><a href="https://developer.apple.com/swift/blog/?id=1" target="_blank">Welcome to Swift Blog</a></h2>
<p>This new blog will bring you a behind-the-scenes look into the design of the Swift language by the engineers who created it, in addition to the latest news and hints to turn you into a productive Swift programmer.</p>
<p>Get started with Swift by downloading <a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_6_beta_3_lpw27r/xcode_6_beta_3.dmg" target="_blank">Xcode 6 beta</a>, now available to all Registered Apple Developers for free. The Swift Resources tab has a ton of great links to videos, documentation, books, and sample code to help you become one of the world’s first Swift experts. There’s never been a better time to get coding!</p>
<p>- The Swift Team </p>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="../chapter5/01_documentation.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: documentation"><i class="fa fa-angle-left"></i></a>
        
        
    </div>
</div>

        
<script src="../gitbook/app.js"></script>

    
    <script src="https://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-livereload/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
